

[
  
  
    
    
      {
        "title": "Command line games",
        "excerpt": "Tic-tac-toe, Snake and Pong written in C ++ as part of the Computer Science project in the Middle School.\n\n\n",
        "content": "Tic-tac-toe, Snake and Pong written in C ++ as part of the Computer Science project in the Middle School.\n\nSnake\n\n\n  \n  \n\n\nA classic game where you collect dollars with a snake. There are 3 difficulty modes to choose from, in which the snake changes speed differently. According to the mode, the reward for collecting points is also bigger. A ranking of the best players is also available.\n\n  \n  \n\n\nSnake  github\n\n\nTic-tac-toe\n\n\n  \n  \n\n\nI wrote the game of tic-tac-toe based on an example in a C++ course I took - “Od Zera do Gier Kodera”. It is designed for two players. It has a 3x3 format, the field to place a mark is selected by using the appropriate numbers. The program then checks the arrangement of signs, which leads to a draw or victory for one of the players.\n\n  \n  \n\n\nTicTacToe  github\n\n\nPong\n\n\n  \n  \n\n\nA game designed for two players. Bounce the ball until one of the players lets it pass. The game goes on until a predetermined number of points.\n\n  \n  \n\n\nPong  github\n\n",
        "url": "/software/2013/05/31/gry-konsolowe/"
      },
    
      {
        "title": "Blu",
        "excerpt": "In this game you can drive car on the hills collecting coins and fuel. Made in C++ along with SFML and Box2D libraries.\n\n\n",
        "content": "In this game you can drive car on the hills collecting coins and fuel. Made in C++ along with SFML and Box2D libraries.\n\n\n  \n  \n\n\nI made the game as part of a project from Computer Science in Middle School. The idea of the game is based on Hill Climb Racing, a popular game at the time. The physics engine of the game is based on the Box2D library. The longer we drive, the more difficult hills we encounter, the higher-value coins we earn, and the rarer we find fuel. I also added engine sounds and music in this game.\n\n\n  \n  \n\n\nBlu  github\n\n",
        "url": "/software/2013/09/23/Blu/"
      },
    
      {
        "title": "2D Racing",
        "excerpt": "A 2D racing game with a top-down view. Written in C++ using SFML and Box2D libraries.\n\n\n",
        "content": "A 2D racing game with a top-down view. Written in C++ using SFML and Box2D libraries.\n\n\n  \n  \n\n\nThis game was also made as part of a project in Computer Science. It allows you to race against opponents on various tracks. You can also create you own tracks in a separate editor, which I also wrote as part of the project. The track is divided into squares of a certain type: straight, left turn, right turn, grass and finish line.\n\n  \n  \n\n\nMap Editor  github\n\n\nBy including information about the squares in the text file and reading the current position of the car, I created a form of artificial intelligence opponents. Opponents react to being on a specific square by turning, accelerating or braking. The entire driving and crash simulation is based on the Box2D library, which resulted in realistic interactions between cars.\n\n  \n  \n\n\n2DRacing  github\n\n",
        "url": "/software/2014/01/18/2dracing/"
      },
    
      {
        "title": "Electronic dice",
        "excerpt": "\n",
        "content": "Electronic dice based on the example from the book “Electronics. From practice to theory”\n\n\n  \n  \n\n\nThe circuit uses a 555 timer circuit to generate pulses, which are then counted in sixes. The corresponding numbers are displayed on the LEDs. The process is stopped by pressing a button, which stops at a “random” value.\n\nConstruction steps:\n\n\n  \n  Prototype on a breadboard\n\n\n\n  \n  Universal board with the components used\n\n\n\n  \n  Finished dice\n\n\n",
        "url": "/electronics/2014/03/22/elektronicznakostka/"
      },
    
      {
        "title": "General-purpose robot",
        "excerpt": "\n",
        "content": "Miał robić kawę…\n\nTutaj wyobraźnia mnie poniosła i chciałem zrobić robota uniwersalnego zdolnego do wykonywania różnych czynności np. przygotować napoje, “chodzić” do sklepu. Oczywiście w zamyśle miała być to pierwsza wersja, na której chciałem zbadać moje możliwości. Podnosić miał jedynie atrapy, a poruszać się jedynie po domu.\n\n\n  \n  \n\n\nPiękna była to konstrukcja i bardzo skomplikowana. Do obsługi wszystkich kończyn planowałem zastosować 11 serw. Znacznie przekroczyło to liczbę kanałów PWM w mikrokontrolerze Atmega88Pa. Dlatego właśnie zmuszony byłem zastosować programowe generowanie PWM, które znacznie bardziej obciąża procesor. Z tego właśnie powodu zmuszony byłem użyć drugi mikrokontroler odpowiedzialny za komunikację z komputerem, sterowaniem silnikami oraz zadawanie poprzez SPI położeń serw do drugiego mikrokontrolera. Wiele rzeczy mogło się zepsuć po drodze, dlatego gdy ostatecznie nie mogłem zapanować nad serwami nie wiedziałem co się dzieje. Dopiero po dłuższym czasie doszedłem do wniosku, że musiałem mieć za słabe źródło zasilania, coś czego wcześniej nawet nie brałem pod uwagę. Jednak pomimo niedziałających serw nie porzuciłem tej konstrukcji. Wciąż miałem działające silniki, którymi mogłem sterować z poziomu komputera. Zająłem się w takim razie niezbędnym elementem takiego robota - wykrywaniem przeszkód oraz mapowaniem. W tym celu chciałem zasotosować parę stereowizyjną. Po wielu przygodach udało mi się wreszcie doprowadzić stereowizję do poziomu zadowalającego. Wciąż jednak występowało dużo szumów - szczególnie na podłodze. Nic dziwnego, podłoga, ściana, to mało szczegółów i ciężko jest uzyskać pewny obraz głębi. Udało się zatem mniej więcej wykrywać przeszkody, jednak gdy doszedł do tego ruch to już kompletnie co innego. Zastosowane kamerki internetowe zwracały poruszone obrazy co jeszcze pogarszało wynik wykrywania. Do tego nie zastosowałem enkoderów, ponieważ planowałem wykrywać punkty szczególne i póżniej na podstawie ich oraz uzyskanej mapy głębokości obliczać przesunięcie. Po takich jednak rozczarowujących efektach stereowizji nie próbowałem już tego rozwiązania.\n\n\n  \n  \n\n\nPomimo, że nie spełnił moich oczekiwań to wyszła z niego ciekawa konstrukcja. I mój początek przygody ze stereowizją i mapowaniem.\n\nW tej konstrukcji wzorowałem się na robocie PR2. Domyślną wersję tej konstrukcji chciałem wykonać 2 razy większą. Zastosowanie tutaj zgięcia w połowie miało na celu zwiększyć zakres chwytania - możliwość schylenia się. Jednak głównym celem była możliwość przetransformowania się w robota jeżdżącego, co umowżliwiłoby wspinanie się po schodach oraz większych przeszkodach. Domyślnie w napędzie chciałem zastosować gąsienice.\n\n\n  \n  \n\n\n",
        "url": "/robots/2014/08/28/universal-robots/"
      },
    
      {
        "title": "3D Viewer",
        "excerpt": "A piece of software for the perspective display of points in 3D.\n\n\n",
        "content": "Program służący do wyświetlania perspektywicznego punktów w 3D.\n\n\n  \n  \n\n\nProgram ten napisałem w ramach lekcji Informatyki w Liceum. Zaimplementowałem wczytywanie chmur punktów z pliku txt. Są one w formacie współrzędne (X, Y, Z), a następnie kolory (R, G, B). Chmury punktów uzyskiwałem poprzez kamery stereowizyjne. Stworzyłem także możliwość wyświetlania kształtów geometrycznych, na przykład domku. Całość została napisana w Pascalu.\n\n\n  \n  \n\n\n3DViewer  github\n\n",
        "url": "/software/2015/04/09/3dviewer/"
      },
    
      {
        "title": "Mapping robot",
        "excerpt": "Robot that drives around and creates a map of the environment.\n\n\n",
        "content": "Robot laptopa wożący pokój mapujący.\n\n\n  \n  \n\n\nTen robot jest drugą, uproszczoną wersją robota uniwersalnego. Wyciągając wnioski z poprzedniej konstrukcji uprościłem robota i jego jedynym zadaniem było mapowanie pomieszczeń. Także aby zadanie się udało zamieniłem Stereowizję na Kinecta, ponieważ rezultaty z niej osiągane nie były zadowalające. Dodałem także enkodery na koła, jednak wciąż zbyt pewny siebie zrobiłem swoje - inkrementalne bazujące na transoptorach. Nie sprawdzały się one idealnie, ale jednak pozwoliły osiągnąć rezultaty.\n\n\n  \n  Prototypowanie eletkroniki\n\n\nTakże w ramach zabawy z robotem zrealizowałem regulator PID i zadawałem punkt, do którego robot dojeżdżał.\n\nPID  github\n\n\n\n  \n  \n\n\nAby stworzyć mapę najpierw podrzebowałem odpowiednio obrobić dane. W danych głębi z Kinecta zawarte były informacje o podłodze oraz obiektach. Musiałem pozbyć się podłogi. Do osiągnięcia tego testowałem 2 metody: dopasowywanie płaszczyzny oparte na RANSACu z OpenCV oraz metodą UV-disparity, która przyspieszała obliczenia - wykrywałem linię zamiast płaszczyzny.\n\n\n  \n  \n\n\nNa tworzoną mapę typu Grid map nakładałem następnie wykryte obiekty. Do wyliczenia przesunięcia robota używałem wyłącznie enkoderów.\n\n  \n  \n\n\nMapowanie Kinect  github\n\n\n\n  \n  \n\n\nMapowanie Stereowizja  github\n\n\nPróbowałem także wykorzystać SLAMa, aby zniwelować niedoskonałości enkoderów. Jednak tutaj barierą był system operacyjny - Windows, na którym nie udało mi się uruchomić żadnej implementacji. Było to także zbyt skomplikowane zadanie jak na wiedzę, którą posiadałem, aby stworzyć własną implementację.\n\n\n  \n  \n\n\nDo sterowania robotem użyłem mikrokontrolera Atmega88Pa. Komunikował się on z komputerem poprzez interfejs UART, wykorzystałem tutaj przejściówkę na USB. Sterował on silnikami - serwami pracy ciągłej. Także mierzył napięcie z transoptorów, zliczając impulsy poprzez zastowanie odpowiedniego progu. Także dla testu wykorzystałem podczerwony czujnik odległości. Do zasilenia całej konstrukcji użyłem akumulatora żelowego. Poprzez mikrokontroler mierzyłem jego napięcie, sprawdzając czy się rozładował. Musiałem także zastosować przetwornicę Step-Up, aby zasilić Kinecta, który wymaga 12V.\n\nSterownik Robota  github\n\n",
        "url": "/robots/2015/08/25/mapping-robot/"
      },
    
      {
        "title": "Tesla coil",
        "excerpt": "\n",
        "content": "\n  \n  \n\n\nInspired by\nElectroBoom\nand\nLudic Science\n\n\n  \n  \n\n\nFirst I made a smaller version based on a single transistor, powered by a 9V battery.\n\n\n  \n  Coil winding\n\n\nThen I made a larger coil, in which I used 4 transistors and an additional heat sink to ensure adequate cooling. I used a power supply from a printer as a power source.\n",
        "url": "/electronics/2015/12/10/cewkatesli/"
      },
    
      {
        "title": "Fuzz guitar effect",
        "excerpt": "\n",
        "content": "\n  \n  \n\n\nGuitar effect made from a schematic:\n\n  \n  \n\n\n\n  \n  \n\n\n",
        "url": "/electronics/2016/08/28/fuzz/"
      },
    
      {
        "title": "Luminous ball",
        "excerpt": "Operate the computer by moving the controller.\n\n\n",
        "content": "Operate the computer by moving the controller.\n\n\n  \n  \n\n\nThe controller inspired by the PlayStation Move. I used a webcam and a controller - a flashlight with a ball. The ball’s movements are tracked and translated into mouse cursor movements. By turning the flashlight on and off a mouse click is simulated.\n\nTo analyze the image I used the OpenCV library and the detection method outlined in the https://forbot.pl/blog/opencv-2-wykrywanie-obiektow-id4888\n\n\n  \n  \n\n\nCode  github\n\n",
        "url": "/software/2017/05/26/move/"
      },
    
      {
        "title": "Hexapod",
        "excerpt": "\n",
        "content": "Sześcionogi stwór z kamerkami.\n\nProjekt, którym zajmowałem się przez pierwsze 2 lata studiów w ramach działalności koła naukowego Integra. Moim wkładem było oprogramowanie do sterowania robota oraz stereowizji.\n\n\n  \n  \n\n\nDo poruszania konstrukcją wykorzystane zostało 18 serw Hitec po 3 na każdą nogę. Jako główny komputer robota wykorzystalismy Raspberry Pi 2. Komunikowała się ona z sterownikiem serw Pololu poprzez interfejs UART umożliwiając zadawanie odpowiednich pozycji serw. Całą konstrukcję zasila bateria LiPol o pojemności 4000 mAh, co pozwalało na ok. 1h użytkowania robota. Napięcie z akumulatora dostowywaliśmy za pomocą przetwornic (3 do zasilania serw oraz 1 dla Raspberry). Wykorzystaliśmy także przetwornik ADC MCP3008, aby móc mierzyć aktualne napięcie na baterii. Komunikował się on z Raspberry za pomocą SPI, a następnie napięcie było wysyłane i wyświetlane w aplikacji klienta.\n\n\n  \n  \n\n\nRobot jest sterowany z poziomu laptopa, który komunikuje się z Raspberry poprzez WiFi przez protokół TCP. Do poruszania robotem można używać zarówno pada jak i klawiatury. W celu odpowiedniego sterowania najpierw napisałem aplikację obrazującą model matematyczny robota. Na tym modelu została zaimplementowana kinematyka odwrotna, na której następnie stworzyłem modele poruszania się robota. Odpowiednio przeliczone uzyskane kąty na sygnały PWM dla serwonapędów były wysyłane do sterownika.\n\n\n  \n  \n\n\nSterowanie robotem\n\nAplikacja uruchamiana na laptopie zawiera wizualizacje modelu robota oraz odbiera sygnały sterowania od użytkownika, które następnie przekazuje do programu na Raspberry. On natomiast dokonuje odpowiednich przeliczeń na sygnały PWM, które następnie przekazuje do sterownika serw. Z Raspberry wysyłana jest także informacja zwrotna do aplikacji użytkownika z aktualnym napięciem na baterii, dzięki czemu jej poziom jest na bieżąco monitorowany. Osobny program służy do realizacji stereowizji. Raspberry wysyła obrazy z obu kamer przy użyciu programu gstreamer. Na laptopie oba obrazy są odbierane i następnie przy użyciu odpowiednich macierzy (uzyskanych podczas kalibracji) przekształcana oraz liczona jest macierz obrazu dysparcji. Zastosowałem także filtr po przeliczeniu dysparcji, który dodatkowo poprawia rezultaty.\n\nAplikacje modelu Hexapoda można pracować w 2 trybach:\n\nTryb modelu\n\nW trybie modelu można poruszać się po środowisku za pomocą klawiszy W/S/A/D/Q/E oraz barów alfa, beta i gamma służących do zmiany kąta widzenia. Modelem robota poruszać można za pomocą klawiszy w/s/a/d/q/e oraz numerów służących do wyboru odpowiedniego trybu chodzenia robota.\n\n\n  \n  \n\n\nTryb połączenia z Hexapodem\n\nUruchamia się jeśli dodatkowo przekażemy do programu przy uruchomieniu adres IP Raspberry. Sterowanie aplikacją na laptopie nie zmienia się. Różnica z poprzednio omówionym trybem (tryb modelu) jest taka, iż teraz odpowiednie komendy wysyłane są także do Hexapoda. Dodatkowo wyświetlane na ekranie laptopa jest również napięcie na baterii.\n\nBliższy opis elementów zrealizowanej aplikacji\n\nGUI\n\nZadaniem najbardziej oddalonym od samej idei Hexapoda był moduł wyświetlania, czyli GUI. Do wyświetlania użyto wyłącznie prostego okienkowego trybu wyświetlania dołączonego do biblioteki OpenCV w celu debugowania. Zastosowałem rzutowanie perspektywiczne zgodnie ze wzorami zawartymi w 1, aby otrzymać symulację w 3D. Zdefiniowałem płaszczyznę kamery, na którą odbywało się rzutowanie świata 3D symulacji. Dodałęm także przesuwanie płaszczyzną kamery za pomocą przycisków oraz możliwość jej obracania przy pomocy toolbarów.\n\nRobot\n\nTo jest główny moduł odpowiedzialny za obliczenia związane ze sterowaniem robota. Zawarłem w nim implementację kinematyki odwrotnej w podejściu trygonometrycznym opisaną w 2. Główna klasa robota zawiera klasę nóg robota, które są wydzielone. Jest osobna klasa, w której znajdują się różne algorytmy chodzenia.\n\nChodzenie\n\nNajlepsze efekty dawało chodzenie po paraboli. Dobierane są kolejne punkty paraboli, która zaczyna się w miejscu, gdzie aktualnie znajduje się końcówka nogi robota. Kończy się tam, gdzie ma się ostatecznie znaleźć. Przy użyciu kinematyki odwrotnej wyliczane są kąty tak, aby końcówka danej nogi znalazła się w punkcie docelowym.\n\nPozostałe moduły\n\nKontroler, który odpowiednio interpretuje wysłane komendy na funkcje, np.: chodzenia lub poruszania bazą robota. Znajduje się tutaj również moduł do komunikacji z serwami (tylko w wersji programu dla Raspberry). Zamieniane są wyliczone kąty dla każdej nogi na odpowiednie sygnały PWM, dla każdego serwa (jedna noga składa się z trzech serwonapędów). Następnie są one wysyłane.\n\nTCP\n\nW module TCP znajduję się cały kod do komunikacji pomiędzy Raspberry a laptopem. Kod został zaczerpnięty z 3. W ramach komunikacji laptop łączy się z Raspberry i na porcie 8081 odbiera aktualne napięcie baterii, które Raspberry stale udostępnia. Komunikacja w ramach odczytu napięcia baterii odbywa się w osobnym wątku, aby nie zakłócać pozostałych operacji. Natomiast na port 8080 aplikacja z laptopa wysyła podane komendy.\n\nAplikacja na laptopa  github\n\n\nAplikacja na Raspberry  github\n\n\nStereowizja\n\nPoniżej przedstawie krótki opis etapów realizacji stereowizji:\n\nWykonanie zdjęć kalibracyjnych\n\nAby skalibrować parę stereowizyjną wykonywane są zdjęcia ustalonego wzoru, np. szachownicy. W tym celu napisałem aplikację, która wyświetlała obraz z obu kamer. Co ustalony czas zapisywała zdjęcie pod odpowiednią nazwą oraz tworzyła listę utworzonych obrazów. Wykonałem około 50 zdjęć tak, aby jak najlepiej pokryć cały obszar widoku kamer.\n\n\n  \n  Przykładowa para zdjęć wykonanych podczas kalibracji\n\n\nWidoczny na zdjęciach zamieszczonych powyżej jest także następny napotkany problem - obiektywy w obudowach kamer zamontowane były nierówno. Oczywiście to przesunięcie eliminowane jest podczas kalibracji, jednak w rezultacie podczas właściwej stereowizji ograniczone jest pole widzenia od góry i dołu (część pixeli widoczna jest tylko przez jedną kamerkę).\n\nKalibracja\n\nDo samej kalibracji użyłem przykładu z książki Learning OpenCV. W parametrach wywołania umieszczano wysokość oraz szerokość szachownicy (liczba pól), a także długość boku kwadratu w centymetrach. Bardzo ważne jest, aby szachownica miała kwadratowe pola, gdyż przy użyciu szachownicy o bokach różniących się nieznacznie cały proces kalibracji zostałby przeprowadzony niepoprawnie wraz z listą zdjęć, powstałych w trakcie tej błędnej kalibracji.\n\n\n  \n  Wynik wykrywania krawędzi szachownicy\n\n\n\n  \n  Wynik rektyfikacji\n\n\nW wyniku działania kalibracji otrzymałem parametry zewnętrzne oraz wewnętrzne kamer, które następnie używane były do właściwej stereowizji. Uzyskano błędy:\nbłąd średniokwadratowy (RMS) = 0.0503053\nśredni błąd epipolarny = 0.517146\nSą to wartości niskie, co świadczy o poprawnie wykonanej kalibracji.\n\nWybór algorytmu oraz dobranie parametrów\n\nNajpierw przetestowałem dostępne w bibliotece OpenCV algorytmy BM i SGBM, lepsze rezultaty uzyskałem dla SGBM. Jest on bardziej wymagający obliczeniowo, aczkolwiek przy rozdzielczości 320x240 można było uzyskać dobre przetwarzanie w czasie rzeczywistym. Następnie dobrałem optymalne parametry dla tego algorytmu. W tym celu napisałem aplikację na podstawie przykładu użycia SGBM zawartego w bibliotece OpenCV. Dodałem do niej suwak tak, aby można było wygodnie zmieniać parametry i obserwować uzyskiwane rezultatu.\n\n\n  \n  Widok okna z paskami do zmiany parametrów\n\n\n\n  \n  Przykładowa scena użyta do doboru parametrów\n\n\n\n  \n  Wynik przeprowadzenia stereowizji\n\n\nDobranie parametrów dla postfiltracji\n\nW celu uzyskania gładszego obrazu stereowizyjnego zastosowałem postfiltrację, która dodana została stosunkowo niedawno do modułów dodatkowych biblioteki OpenCV - contrib.\n\n\n  \n  Efekt przeprowadzenia algorytmu SGBM przy optymalnych parametrach\n\n\n\n  \n  Efekt przeprowadzenia postfiltracji\n\n\nOstateczna aplikacja\n\nW ostatecznej aplikacji połączone zostały wszystkie opisane elementy. W wyniku czego otrzymano przesył obrazu z obu kamer na laptopa. Tam obraz był rektyfikowany, a pixele były dopasowywane za pomocą algorytmu SGBM. Przy użyciu posfiltracji obraz dysparcji jest poprawiany i na koniec wyświetlany. Dalszym etapem rozwojowym może być przeliczenie chmury punktów na podstawie dysparcji oraz następnie wykrywanie i omijanie przeszkód.\n\nPoza samą realizacją stereowizji ważnym elementem był także optymalny przesył obrazu z obu kamer. Pierwszym podejściem było użycie MJPGstreamera. Efekty jednak nie były zadowalające. Klatki, które nie zostały jeszcze wysłane, były składowane w buforze. W wyniku czego, im dłużej działała aplikacja, tym większe było opóźnienie. Dodatkowo występowała różnica czasu pomiędzy klatkami z obu kamer, co w przypadku stereowizji jest nieakceptowalne. Dlatego zdecydowano się użyć gstreamera. Jest on bardziej zaawansowany, przez co uruchomienie go zajęło więcej czasu. Jednak uzyskany efekt jest bardzo dobry. W jego działaniu, jeśli nie zdąży się wysłać klatki przed przybyciem następnej, to zostaje ona porzucona. W wyniku tego wyeliminowane zostało rosnące opóźnienie. Dlatego też nie występowało już opóźnienie pomiędzy klatkami. Rozdzielczość przesyłanych obrazów wynosi 320x240. Przeprowadzono także testy dla rozdzielczości 640x480, ale spadek FPS był nieproporcjonalny do wzrostu jakości.\n\nStereowizja  github\n\n\nOsiągnięcia\n\nZawody robotyczne\n\n\n  Robocomp 2017 w Krakowie (kategoria Freestyle)\n  Robotic Arena 2017 we Wrocławiu (kategorie Freestyle oraz wyścig robotów kroczących). Pierwsze miejsce w kategorii wyścig robotów kroczących.\n  Robomaticon 2018 w Warszawie (kategoria Freestyle)\n  Robotic Tournament 2018 w Rybniku (kategoria Freestyle)\n  Robotic Arena 2019 we Wrocławiu. Drugie miejsce w kategorii wyścig robotów kroczących.\n\n\nWydarzenia\n\n\n  Targi pracy Kariera IT\n  TEDxAGHUniversity\n\n\n\n  \n  Prezentacja na zawodach Robotic Arena fot. Politechnika Wrocławska\n\n\nStrona projektu\n",
        "url": "/robots/2018/06/08/hexapod/"
      },
    
      {
        "title": "Tank",
        "excerpt": "\n",
        "content": "Pojazd uniwersalny oparty o Raspberry Pi Zero.\n\n\n  \n  \n\n\nUmożliwia obserwację obrazu z kamerki, odczyt napięcia na baterii (poziom rozładowania ), temperatury z Raspberry oraz wartości enkoderów. Dotychczas odczytów z enkoderów nie wykorzystałem w sposób praktyczny, jednak zamieszczenie ich umożliwi dalszy rozwój konstrukcji.\n\n\n  \n  \n\n\nProjekt ten zaczął się od płytki PCB.\n\n  \n  Płytka wraz z podłączonymi wszystkimi elementami\n\n\nMiała być wykorzystana do sterowania robotem z następującymi elementami:\n\n\n  dwa silniki z enkoderami\n  trzy serwa\n  komunikacja z Raspberry pooprzez SPI\n  pomiar napięcia z baterii\n  dwa LEDy ( uruchomienie oraz rozładowanie)\n\n\n\n  \n  Złożony schemat prototypowany na płytce stykowej\n\n\nJako źródło zasilania wykorzystałem LiPola oraz 2 przetwornicę: jedną do logigki oraz drugą do serw. W trakcie realizacji projektu jednak zorientowałem się, że ten mikrokontroler jest za słaby. Było to spowodowane tym, że potrzebowałem 3 kanałów PWM do serw oraz 2 do sterowania prędkością silników. Nie miałem jednak dostępnej takiej liczby, dlatego sygnały PWM dla serw musiałem generować programowo, przez co znacznie wzrosło obciążenie procesora. Doliczając do tego bardzo często przerwania zewnętrzne z dwóch enkoderów, nie byłem w stanie dostarczyć wystarczająco dokładnego przebiegu PWM by sterować serwami. Dlatego ostatecznie pominąłem użycie serw w tym projekcie.\n\n\n  \n  \n\n\nKonstrukcja czołgu została wykonana na drukarce 3D, a jej projekt zaczerpnąłem z\nhttps://www.thingiverse.com/thing:652851\n\n\n  \n  Płytka po wytrawieniu\n\n\nRobotem steruje się poprzez przeglądarkę. W tym celu użyłem skryptu z https://hackaday.io/project/25092-zerobot-raspberry-pi-zero-fpv-robot/log/97988-the-new-zerobot-pro\n,który odpowiednio przerobiłem do swoich potrzeb ( zamiana sterowania na takie wykorzystujące SPI).\n\nProjekt  github\n\n",
        "url": "/robots/2019/03/27/tank/"
      },
    
      {
        "title": "Human following robot",
        "excerpt": "Every move you make |\nEvery step you take |\nI’ll follow you\n\n\n",
        "content": "In this tutorial I describe one way to make robot detect and follow people - it won’t make a great spy but could be useful to carry luggage or groceries. Whole system was implemented on Husarion’s ROSbot with ESP32 as a remote. To find people I used scans from LiDAR (RPLidar A2) with my detector, which is simple but turned out to be fast and quite reliable. I also checked other LiDAR approaches available on ROS - leg_detector and leg_tracker but in this case didn’t perform well enough. Another package I tested is upper_body_detector, which uses RGBD camera to detect humans. As name suggests it needs to see upper part of body - this will be a problem if we want our robot to stay close, also in this case it didn’t perform very well and was slower.\n\n\n  \n  \n\n\nSetup\n\nESP32 Remote\n\nEnvironment\n\nYou will need to follow tutorial about setting up rosserial connection over Internet with ESP32. On ROSbot prepare Husarnet connection and Rosserial for Husarnet. I recommend to set up Arduino IDE on your computer (remember to also get Rosserial for Husarnet).\n\nCode\n\nCreate new sketch in Arduino IDE and copy code:\nESP Remote Code\n\nThen get your Husarnet join code and customize code as described in ESP32 Husarnet Tutorial\n\nWiring\n\nWire your ESP32 accordingly to schematics:\n\n\n  \n  \n\n\nAs a source of power you can use a Powerbank connected to the ESP.\n\nROSbot\n\nThis project is meant to run on CORE2 with Mbed firmware. So be sure that you updated your firmware as described in ROSbot quick start. On ROSbot you will need to install following dependencies:\n\n\n  scikit-learn python library (for clusterization)\n    sudo apt-get install python-scikits-learn\n    \n  \n  \n    pykalman\nFollow installation tutorial on pykalman page\n  \n  rosbot_description package (for URDF visualization model and bridge node)\nGo to your ROS workspace and clone repository:\n    cd ~/ros_workspace/src\ngit clone https://github.com/husarion/rosbot_description.git\n    \n    Install dependencies:\n    cd ~/ros_workspace\nrosdep install --from-paths src --ignore-src -r -y\n    \n  \n  rosbot_ekf\nInstall dependency:\n    sudo apt-get install ros-kinetic-robot-localization\n    \n    Get package:\n    git clone https://github.com/byq77/rosbot_ekf.git\n    \n  \n\n\nThen go back to src folder in your workspace:\n\ncd ~/ros_workspace/src\n\n\nDownload code:\n\ngit clone https://github.com/macstepien/rosbot_follower.git\n\n\nAnd finally build your workspace:\n\ncd ~/ros_workspace\ncatkin_make\n\n\nUsage\n\nThere are two options available:\n\n\n  followerSlow - better if you have little space and walk slowly.\nTo run it you only need to copy this commande into new terminal window:\n    roslaunch rosbot_follower followerSlow.launch\n    \n  \n  followerKalman - this one should be able to follow you with normal walking, but it also needs some space to gain speed.\nRoslaunch command:\n    roslaunch rosbot_follower followerKalman.launch\n    \n  \n\n\nAfter whole system is up and running stand in front of ROSbot, but not too far away. When you are detected blue LED on ESP should turn on. Then you can press first button (the one closer to ESP on schematics) and if you start walking robot should follow you. When LED turns off it means that algorithm lost detection of you and need to recalibrate (stand closer to robot and wait until blue LED is back on). If robot had false detection you can calibrate again by pressing second button. On RViz you can see visualization: scan from LiDAR, robot model and detections. Green spheres are all potential legs, blue cylinders are detected legs and red tall cylinder is human position. In version with Kalman filter we also publish circle around human, which shows how much estimated position differs from measurement.\n\n\n  \n  \n\n\nTroubleshooting\n\n\n  LED doesn’t turn on - check RViz if you can see detected human (red cylinder). If there is a detection then press Dead Man’s Button and try to walk.\n  ROSbot doesn’t respond - you should check your connection to ESP32. You can do so by echoing button topic:\n    rostopic echo /esp_remote/start\n    \n    If nothing can be seen, try restarting your ESP by turning it off and on again.\n  \n\n\nAlgorithm walkthrough\n\nFirst we will go through slower version, as it is simpler. Main part of this code is scan callback where all the magic happens - data from LiDAR is analyzed and people are detected. Whole process consists of 5 steps:\n\n\n  Clusterization\n  Leg detection\n  Human detection\n  Marker publishing\n  Control\n\n\n1. Clusterization\n\ndef scanCallback(self, scan):\n    clusterList = self.findClusters(scan)\n    ...\n\n\nFirst we find clusters in our scan using Euclidean Clusterization Algorithm:\n\ndef findClusters(self, scan):\n    pointsList = np.zeros((0, 2))\n    i = 0\n    for r in scan.ranges:\n        if r &gt; self.minRange and r &lt; self.maxRange:\n            alfa = scan.angle_min + i * scan.angle_increment\n            x = r * math.cos(alfa)\n            y = r * math.sin(alfa)\n            if (alfa &gt; -math.pi and alfa &lt; -self.maxAngle) or \\\n                (alfa &gt; self.maxAngle and alfa &lt; math.pi):\n                pointsList = np.append(pointsList, [[x, y]], axis=0)\n        elif r &lt; self.minRange:\n            rospy.logerr(\"Obstacle detected\")\n            return [np.zeros((1, 2))]\n        i += 1\n    db = DBSCAN(eps=self.clusterizationMaxDistanceParam,\n                min_samples=self.clusterizationMinSamplesParam).fit(pointsList)\n    core_samples_mask = np.zeros_like(db.labels_, dtype=bool)\n    core_samples_mask[db.core_sample_indices_] = True\n    labels = db.labels_\n    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)\n    unique_labels = set(labels)\n    clusterList = []\n    for k in unique_labels:\n        class_member_mask = (labels == k)\n        xy = pointsList[class_member_mask &amp; core_samples_mask]\n        if xy.any():\n            clusterList.append(xy)\n    return clusterList\n\n\nHere we have few parameters that you can customize:\n\n\n  minRange - used to filter ranges from lidar points, if anything gets closer than that, then ROSbot treats it as obstacle and stops\n  maxRange - data from lidar further than that value are dismissed\n  maxAngle - readings have to be in front of ROSbot in ranges (maxAngle, Pi) u (-Pi, -maxAngle)\n  clusterizationMaxDistanceParam - maximum distance between points to add new point to cluster\n  clusterizationMinSamplesParam - minimum number of points in cluster\n\n\nMore information about DBSCAN clusterization\n\nBack to scanCallback:\n\ndef scanCallback(self, scan):\n    ...\n    if len(clusterList) == 0:\n    \trospy.logwarn(\"No clusters detected\")\n    \tif rospy.get_time() - self.lastDetectionTime &lt; self.detectionTimeout:\n            humanPosition = self.lastHumanPosition\n            self.controlRosbot(humanPosition)\n    \telse:\n            led = Bool()\n            led.data = False\n            self.ledPub.publish(led)\n            self.positionCalibration = True\n            rosbotControl = Twist()\n            self.speedPub.publish(rosbotControl)\n    \treturn\n    elif (clusterList[0][0, 0] == 0) and (clusterList[0][0, 1] == 0):\n    \tled = Bool()\n    \tled.data = False\n    \tself.ledPub.publish(led)\n    \tself.positionCalibration = True\n    \trosbotControl = Twist()\n    \tself.speedPub.publish(rosbotControl)\n    \treturn\n    ...\n\n\nIn here we check results of clusterization. If we didn’t detect anything, we continue movement in last seen human position. That is until our last seen position is too old - then we need to stop and assume we lost track of our human, which we signal through LED.\nWe pass special value when obstacle is detected - in first cluster first point is set to (0,0). In this case robot needs to stop immediately, as obstacle is too close.\n\n\n  detectionTimeout - how much time (in seconds) we can trust last seen position and follow it\n\n\n2. Leg detection\n\nNext step is leg detection:\n\ndef scanCallback(self, scan):\n    ...\n    sortedClusters = self.detectLegs(clusterList)\n    ...\n\n\ndef detectLegs(self, clusterList):\n    i = 0\n    sortedClusters = []\n    for cluster in clusterList:\n    \txMax = np.max(cluster[:, 0])\n    \txMin = np.min(cluster[:, 0])\n    \tyMax = np.max(cluster[:, 1])\n    \tyMin = np.min(cluster[:, 1])\n    \txDistance = xMax - xMin\n    \tyDistance = yMax - yMin\n    \tproportion = max(xDistance,yDistance)/min(xDistance, yDistance)\n    \tarea = xDistance*yDistance\n    \tif not (max(xDistance,yDistance)-self.legWidth) &lt; self.dLegWidth:\n    \t\tcontinue\n    \txMean = (xMax+xMin)/2\n    \tyMean = (yMax+yMin)/2\n    \tcone = Point()\n    \tcone.x = xMean\n    \tcone.y = yMean\n    \tcone.z = 0\n    \tsortedClusters.append(cone)\n    sortedClusters.sort(key=lambda x: math.sqrt(x.x**2 + x.y**2))\n    return sortedClusters\n\n\nIn this section we go through each cluster and calculate its bounding rectangle. Then we filter our data with following rule: longer side of rectangle can have maximal length of legWidth + dLegWidth (meaning that we assume leg width of legWidth with upper toleration dLegWidth). I encourage you to experiment with it and maybe try other conditions e.g. area and sides proportions. If cluster passes we find its centroid and save it for further calculations. As last thing we sort our potential legs by distance from ROSbot.\n\n\n  legWidth - width of the leg\n  dLegWidth - toleration of leg width\n\n\ndef scanCallback(self, scan):\n    ...\n    if len(sortedClusters) == 0:\n    \trospy.logwarn(\"No legs detected\")\n    \tif rospy.get_time() - self.lastDetectionTime &lt; self.detectionTimeout:\n            humanPosition = self.lastHumanPosition\n            self.controlRosbot(humanPosition)\n    \telse:\n            led = Bool()\n            led.data = False\n            self.ledPub.publish(led)\n            self.positionCalibration = True\n            rosbotControl = Twist()\n            self.speedPub.publish(rosbotControl)\n    \treturn\n    ...\n\n\nSimilar to previous step we check results of leg detection. No legs found - we allow ROSbot to move for some time. This step is necessary to smooth out movement - sometimes in only one frame we don’t detect any legs, which can cause robot to stop and go.\n\n3. Human detection\n\nWe estimate human position through analysis of legs detections:\n\ndef scanCallback(self, scan):\n    ...\n    (firstLeg, secondLeg, humanPosition, firstLegDetected, twoLegsDetected) = self.detectHuman(sortedClusters)\n    ...\n\n\ndef detectHuman(self, sortedClusters):\n    firstLeg = sortedClusters[0]\n    firstLegDetected = False\n    twoLegsDetected = False\n    secondLeg = Point()\n    humanPosition = Point()\n    humanPositionTemp = Point()\n    if len(sortedClusters) &gt; 2:\n    \tsortedClusters.sort(key=lambda x: math.sqrt((x.x-firstLeg.x)**2 + (x.y-firstLeg.y)**2))\n    \tsecondLeg = sortedClusters[1]\n    \tlegDistance = math.sqrt((firstLeg.x - secondLeg.x)**2 + (firstLeg.y - secondLeg.y)**2)\n    \tif legDistance &lt; self.legDistanceThreshold:\n            humanPositionTemp.x = (firstLeg.x+secondLeg.x)/2\n            humanPositionTemp.y = (firstLeg.y+secondLeg.y)/2\n            humanPositionTemp.z = 0\n            twoLegsDetected = True\n    \telse:\n            humanPositionTemp = firstLeg\n    else:\n    \thumanPositionTemp = firstLeg\n    if self.positionCalibration:\n    \tr = math.sqrt( humanPositionTemp.x ** 2 + humanPositionTemp.y ** 2)\n    \tif r &lt; self.calibrationDistance and twoLegsDetected:\n            self.lastHumanPosition = humanPositionTemp\n            humanPosition = humanPositionTemp\n            firstLegDetected = True\n            self.lastDetectionTime = rospy.get_time()\n            self.positionCalibration = False\n            led = Bool()\n            led.data = True\n            self.ledPub.publish(led)\n    else:\n    \tdistanceChange = math.sqrt((self.lastHumanPosition.x - humanPositionTemp.x)**2 \\\n    \t\t\t\t+ (self.lastHumanPosition.y - humanPositionTemp.y)**2)\n    \tif distanceChange &lt; self.humanPositionChangeThreshold:\n            humanPosition = humanPositionTemp\n            firstLegDetected = True\n            self.lastHumanPosition = humanPosition\n            self.lastDetectionTime = rospy.get_time()\n    \telse:\n            if rospy.get_time() - self.lastDetectionTime &lt; self.detectionTimeout:\n                humanPosition = self.lastHumanPosition\n            else:\n                led = Bool()\n                led.data = False\n                self.ledPub.publish(led)\n                self.positionCalibration = True\n    return (firstLeg, secondLeg, humanPosition, firstLegDetected, twoLegsDetected)\n\n\nWe assume our first detected leg is one closest to ROSbot. Second leg (if any available) is one closest to first leg (if it’s close enough). With two legs detected we calculate possible human position as mean between legs, otherwise we use first leg as possible human position.\nWhen human position is not calibrated, then two legs have to be visible in range closer than given threshold. Provided that our position is already calibrated, we can check if our detected human position is viable. We calculate difference in positions between new and old detection, too big value means that it’s probably false detection. In this case we check if we can use older position, otherwise we lost track of human position.\n\n\n  legDistanceThreshold - maximum distance from first leg to second leg, if second leg distance is more than that, we use only first leg detection\n  calibrationDistance - maximum distance from human to ROSbot to initialize position\n  humanPositionChangeThreshold - maximum distance between last detected human position and recent human position\n  detectionTimeout - how much time we can use old detection as human position, if we exceed this time we consider that we lost our human detection\n\n\n4. Marker publishing\n\nVisualization of our detections\n\ndef scanCallback(self, scan):\n    ...\n    self.publishMarkers(firstLeg, secondLeg, humanPosition, firstLegDetected, twoLegsDetected, sortedClusters)\n    ...\n\n\ndef publishMarkers(self, firstLeg, secondLeg, humanPosition, firstLegDetected, twoLegsDetected, sortedClusters):\n    legMarker = Marker()\n    legMarker.header.frame_id = \"laser\"\n    legMarker.ns = \"person\"\n    legMarker.header.stamp = rospy.Time()\n    legMarker.type = Marker.CYLINDER\n    legMarker.action = Marker.ADD\n    legMarker.pose.orientation.x = 0.0\n    legMarker.pose.orientation.y = 0.0\n    legMarker.pose.orientation.z = 0.0\n    legMarker.pose.orientation.w = 1.0\n    legMarker.scale.x = 0.04\n    legMarker.scale.y = 0.04\n    legMarker.scale.z = 0.04\n    legMarker.color.a = 1.0\n    legMarker.color.r = 0.0\n    legMarker.color.g = 0.0\n    legMarker.color.b = 1.0\n    legMarker.lifetime = rospy.Duration(0.5)\n    if not self.positionCalibration:\n    \t#first leg\n        if firstLegDetected:\n            legMarker.id = 1\n            legMarker.pose.position = firstLeg\n            legMarker.pose.position.z = 0.02\n            self.legPub.publish(legMarker)\n        #second leg\n        if twoLegsDetected:\n            legMarker.id = 2\n            legMarker.pose.position = secondLeg\n            self.legPub.publish(legMarker)\n    \t#human position\n    \tlegMarker.id = 3\n    \tlegMarker.scale.z = 0.2\n    \tlegMarker.pose.position = humanPosition\n    \tlegMarker.pose.position.z = 0.1\n    \tlegMarker.color.r = 1.0\n    \tlegMarker.color.b = 0.0\n    \tself.legPub.publish(legMarker)\n    legMarker = Marker()\n    legMarker.ns = \"legs\"\n    legMarker.header.frame_id = \"laser\"\n    legMarker.header.stamp = rospy.Time()\n    legMarker.type = Marker.SPHERE\n    legMarker.action = Marker.ADD\n    legMarker.pose.orientation.x = 0.0\n    legMarker.pose.orientation.y = 0.0\n    legMarker.pose.orientation.z = 0.0\n    legMarker.pose.orientation.w = 1.0\n    legMarker.scale.x = 0.04\n    legMarker.scale.y = 0.04\n    legMarker.scale.z = 0.04\n    legMarker.color.a = 1.0\n    legMarker.color.r = 0.0\n    legMarker.color.g = 1.0\n    legMarker.color.b = 0.0\n    legMarker.lifetime = rospy.Duration(0.2)\n    i = 1\n    for x in sortedClusters:\n    \tlegMarker.id = i\n    \ti += 1\n    \tlegMarker.pose.position.x = x.x\n    \tlegMarker.pose.position.y = x.y\n    \tself.legPub.publish(legMarker)\n\n\nPretty straightforward: we publish markers with potential legs (green spheres), detected legs (if any found, blue cylinders) and human (red cylinder).\n\n5. Control\n\nAnd final step is movement control:\n\ndef scanCallback(self, scan):\n    ...\n    self.controlRosbot(humanPosition)\n\n\ndef controlRosbot(self, humanPosition):\n    r = math.sqrt( humanPosition.x ** 2 + humanPosition.y ** 2)\n    a = math.atan2(humanPosition.y, -humanPosition.x)\n    if r &gt; self.minHumanDistance:\n    \txSpeed = -r * self.speedPGain\n    else:\n    \txSpeed = 0\n    if abs(a) &gt; self.minHumanAngle:\n    \tzAngularSpeed = a * self.angularSpeedPGain\n    else:\n    \tzAngularSpeed = 0\n    rosbotControl = Twist()\n    if rospy.get_time() - self.buttonTime &lt; self.buttonTimeout and \\\n    \t\tself.buttonState == True and not self.positionCalibration:\n    \trosbotControl.linear.x = xSpeed\n    \trosbotControl.angular.z = zAngularSpeed\n    \tself.speedPub.publish(rosbotControl)\n    else:\n    \tself.speedPub.publish(rosbotControl)\n\n\nFirstly we convert our cartesian coordinates to polar ones. Then we calculate angular and linear speed for ROSbot with proportional controller. We publish it if we receive message from remote that allow robot to move.\n\n\n  minHumanDistance - if human distance is more than that robot will start following\n  minHumanAngle - if human angle is more than that robot will start following\n  speedPGain - proportional gain for linear ROSbot speed (increase if you want your robot to go faster)\n  angularSpeedPGain - proportional gain for angular ROSbot speed (increase if you want your robot to turn faster)\n  buttonTimeout (seconds) - if we don’t receive new Dead Man’s Button message for that time ROSbot isn’t allowed to move\n\n\nFollowerKalman\n\nThis version is improved slow follower - basically only additions are scoring system and Kalman filter. Also I changed some parameters to make it more suitable for higher speeds.\nIn order to implement Kalman filter I created Person class where human position is stored and updated. For Kalman Filter part I used code from leg_tracker. All the parameters for filter were well tuned, I only changed std_obs value.\n\n\n  std_obs - increasing this value means you don’t trust your measurements and as the effect your data is much more filtered. Be careful with changing it too much, because it causes your estimated human position to be slower to sudden changes - if you stop, filter won’t trust as much your readings and as a result it will predict you will still move with some velocity. Consequently robot will continue moving forward and it will take some time to adjust to reality. On the other hand if you decrease it too much human position will fluctuate with uncertainties in leg detections.\n\n\nNext big change is that I added scoring system which uses all parameters: proportion, area, length and distance. It combines it with appropriate weights.\n\nproportion = max(xDistance,yDistance)/min(xDistance, yDistance)\narea = xDistance*yDistance\nwidthDifference = (max(xDistance,yDistance)-self.legWidth) - self.dLegWidth\ndistanceFromRobot = math.sqrt(xMean**2 + yMean**2)\nscore = 0\nscore += distanceFromRobot * self.distanceWeight\nscore += abs(proportion - self.destProportion) * self.proportionWeight\nscore += abs(area - self.destArea) * self.areaWeight\nif widthDifference &gt; 0:\n    score += (abs(widthDifference) * self.widthDifferenceWeight)**2\nif score &lt; self.maxScore:\n    sortedClustersDetails.append([xMean, yMean, distanceFromRobot, proportion, area, widthDifference, score])\n\n\nParameters:\n\n\n  destProportion - our desired proportion, I set it based on readings I got\n  destArea - same as above but with area\n  distanceWeight - weight we give to distance from robot\n  proportionWeight - weight we set to distance between measured proportion and desired\n  areaWeight - don’t set this weight too high, as it is not as reliable\n  widthDifferenceWeight - we set it really high, because when reading is too long, then it’s probably not a leg\n  maxScore - above that score we are certain that detection isn’t a leg\n\n\nParameters with updated values:\n\n\n  minRange (increased) - robot has to detect obstacles earlier\n  speedPGain (increased) - increase in proportional gain to obtain higher speed\n  angularSpeedPGain (increased) - same as above\n  minHumanDistance (decreased) - robot will start following earlier and be able to keep up with human\n  humanPositionChangeThreshold (increased) - person walks faster so position can change more\n  detectionTimeout (decreased) - higher speeds, so we decrease timeouts\n  buttonTimeout (decreased) - same as above\n\n\nLastly I added restrictions on obstacle detect - we only detect obstacle approximately in area where we can drive. Increasing minRange can cause ROSbot to be unable to move in narrow spaces.\n\nif (alfa &gt; -math.pi and alfa &lt; -self.maxAngle) or \\\n\t(alfa &gt; self.maxAngle and alfa &lt; math.pi):\n\n\nSummary\n\nIn this tutorial you learned how to set up and run human following using ROSbot with ESP remote. After main algorithm walkthrough you should be also able to modify it to suit your robot.\n",
        "url": "/robots/2019/09/24/human-following-robot/"
      },
    
      {
        "title": "Roomac",
        "excerpt": "Affordable autonomous mobile manipulation robot\n\n\n",
        "content": "Roomac is a low-cost autonomous mobile manipulation robot. It consists of differential drive mobile base and 5-DoF manipulator with gripper. Whole construction costed around 550$ and using this platform I was able to prepare proof-of-concept application - bringing bottle to the user.\n\n\n  \n  \n\n\n",
        "url": "/robots/2022/10/20/roomac/"
      },
    
  
  
  
  {
    "title": "Stereowizja",
    "excerpt": "\n",
    "content": "\n",
    "url": "/posts_pl/-02-10-stereovision/"
  },
  
  {
    "title": "Gry konsolowe",
    "excerpt": "Kółko i krzyżyk, Snake oraz Pong napisane w C++ w ramach projektu z Informatyki w Gimnazjum.\n\n\n",
    "content": "Kółko i krzyżyk, Snake oraz Pong napisane w C++ w ramach projektu z Informatyki w Gimnazjum.\n\nSnake\n\n\n  \n  \n\n\nKlasyczna gra, w której zbieramy wężem dolary. Do wyboru 3 tryby trudności, w których wąż różnie zmienia prędkość. Odpowiednio do trybu większa jest także nagroda za zbieranie punktów. Dostępny jest także ranking najlepszych graczy.\n\n  \n  \n\n\nSnake  github\n\n\nKółko i krzyżyk\n\n\n  \n  \n\n\nGrę kółko i krzyżyk napisałem na podstawie przykładu w kursie C++, który przerabiałem - “Od Zera do Gier Kodera”. Przeznaczona jest dla dwóch graczy. Ma format 3x3, pole do postawienia znaku wybiera się za pomocą odpowiednich cyfr. W programie sprawdzane są następnie ułożenia znaków, które prowadzą do remisu lub zwycięstwa jednego z graczy.\n\n  \n  \n\n\nTicTacToe  github\n\n\nPong\n\n\n  \n  \n\n\nGra przeznaczona dla dwóch graczy. Odbijamy piłkę aż do przepuszczenia jej przez jednego z graczy. Gra toczy się do ustalonej wcześniej ilości punktów.\n\n  \n  \n\n\nPong  github\n\n",
    "url": "/posts_pl/2013-05-31-gry-konsolowe/"
  },
  
  {
    "title": "Blu",
    "excerpt": "Gra, w której jeździmy samochodem po wzgórzach zbierając monety oraz paliwo. Wykonana w języku C++ wraz z bibliotekami SFML oraz Box2D.\n\n\n",
    "content": "Gra, w której jeździmy samochodem po wzgórzach zbierając monety oraz paliwo. Wykonana w języku C++ wraz z bibliotekami SFML oraz Box2D.\n\n\n  \n  \n\n\nGrę wykonałem w ramach projektu z Informatyki w Gimnazjum. Pomysł gry bazuje na popularnej w tym okresie grze Hill Climb Racing. Symulacja fizyczna gry oparta jest na bibliotece Box2D. Im dłużej jedziemy tym spotykamy trudniejsze wzgórza, zdobywamy monety o wyżeszej wartości oraz rzadziej znajdujemy paliwo. W tej grze dodałem także odgłosy silnika oraz muzykę.\n\n\n  \n  \n\n\nBlu  github\n\n",
    "url": "/posts_pl/2013-09-23-Blu/"
  },
  
  {
    "title": "2D Racing",
    "excerpt": "Gra wyścigowa 2D z widokiem od góry. Napisana w języku C++ przy pomocy bibliotek SFML oraz Box2D.\n\n\n",
    "content": "Gra wyścigowa 2D z widokiem od góry. Napisana w języku C++ przy pomocy bibliotek SFML oraz Box2D.\n\n\n  \n  \n\n\nGra ta została wykonana także w ramach projektu z Informatyki. Umożliwia ściganie się z przeciwnikami na różnych torach. Możemy także tworzyć własne trasy w osobnym edytorze, który także napisałem w ramach projektu. Tor podzielony jest na kwadraty o określonym typie: prosta, zekręt w lewo, prawo, trawa oraz meta.\n\n  \n  \n\n\nEdytor map  github\n\n\nDzięki zawarciu w pliku tekstowym informacji o odpowiednich kwadratach oraz odczycie aktualnej pozycji samochodu wprowadziłem pewną formę sztucznej inteligencji, z którą możemy się wyścigować. Przeciwnicy reagują na znalezienie się na fragmencie toru odpowiednio skręcaniem, przyspieszaniem lub hamowaniem. Cała symulacja jazdy oraz zderzeń oparta jest na bibliotece Box2D. Dzięki temu udało mi się uzyskać realistyczne interakcje między samochodami.\n\n  \n  \n\n\n2DRacing  github\n\n",
    "url": "/posts_pl/2014-01-18-2dracing/"
  },
  
  {
    "title": "Elektroniczna kostka",
    "excerpt": "Projekt elektronicznej kostki wykonany na podstawie przykładu w książce “Elektronika. Od praktyki do teorii”\n\n\n",
    "content": "Projekt elektronicznej kostki wykonany na podstawie przykładu w książce “Elektronika. Od praktyki do teorii”\n\n\n  \n  \n\n\nW układzie wykorzystany jest układ czasowy 555 do generacji impulsów, które następnie zliczane są w szóstkach. Odpowiednie liczby są wyświetlane na diodach. Proces zatrzymywany jest przez wciśnięcie przycisku co powoduje zatrzymanie się na “losowej” wartości. Impulsy są generowany na tyle szybko, że nie da sie wychwycić jaka aktualnie cyfra jest wyświetlana.\n\nProces wykonania:\n\n\n  \n  Prototyp na płytce stykowej\n\n\n\n  \n  Płytka uniwersalna wraz z użytymi elementami\n\n\n\n  \n  Zmontowana kostka\n\n",
    "url": "/posts_pl/2014-03-22-elektronicznakostka/"
  },
  
  {
    "title": "Robot uniwersalny",
    "excerpt": "Miał robić kawę…\n\n\n",
    "content": "Miał robić kawę…\n\nTutaj wyobraźnia mnie poniosła i chciałem zrobić robota uniwersalnego zdolnego do wykonywania różnych czynności np. przygotować napoje, “chodzić” do sklepu. Oczywiście w zamyśle miała być to pierwsza wersja, na której chciałem zbadać moje możliwości. Podnosić miał jedynie atrapy, a poruszać się jedynie po domu.\n\n\n  \n  \n\n\nPiękna była to konstrukcja i bardzo skomplikowana. Do obsługi wszystkich kończyn planowałem zastosować 11 serw. Znacznie przekroczyło to liczbę kanałów PWM w mikrokontrolerze Atmega88Pa. Dlatego właśnie zmuszony byłem zastosować programowe generowanie PWM, które znacznie bardziej obciąża procesor. Z tego właśnie powodu zmuszony byłem użyć drugi mikrokontroler odpowiedzialny za komunikację z komputerem, sterowaniem silnikami oraz zadawanie poprzez SPI położeń serw do drugiego mikrokontrolera. Wiele rzeczy mogło się zepsuć po drodze, dlatego gdy ostatecznie nie mogłem zapanować nad serwami nie wiedziałem co się dzieje. Dopiero po dłuższym czasie doszedłem do wniosku, że musiałem mieć za słabe źródło zasilania, coś czego wcześniej nawet nie brałem pod uwagę. Jednak pomimo niedziałających serw nie porzuciłem tej konstrukcji. Wciąż miałem działające silniki, którymi mogłem sterować z poziomu komputera. Zająłem się w takim razie niezbędnym elementem takiego robota - wykrywaniem przeszkód oraz mapowaniem. W tym celu chciałem zasotosować parę stereowizyjną. Po wielu przygodach udało mi się wreszcie doprowadzić stereowizję do poziomu zadowalającego. Wciąż jednak występowało dużo szumów - szczególnie na podłodze. Nic dziwnego, podłoga, ściana, to mało szczegółów i ciężko jest uzyskać pewny obraz głębi. Udało się zatem mniej więcej wykrywać przeszkody, jednak gdy doszedł do tego ruch to już kompletnie co innego. Zastosowane kamerki internetowe zwracały poruszone obrazy co jeszcze pogarszało wynik wykrywania. Do tego nie zastosowałem enkoderów, ponieważ planowałem wykrywać punkty szczególne i póżniej na podstawie ich oraz uzyskanej mapy głębokości obliczać przesunięcie. Po takich jednak rozczarowujących efektach stereowizji nie próbowałem już tego rozwiązania.\n\n\n  \n  \n\n\nPomimo, że nie spełnił moich oczekiwań to wyszła z niego ciekawa konstrukcja. I mój początek przygody ze stereowizją i mapowaniem.\n\nW tej konstrukcji wzorowałem się na robocie PR2. Domyślną wersję tej konstrukcji chciałem wykonać 2 razy większą. Zastosowanie tutaj zgięcia w połowie miało na celu zwiększyć zakres chwytania - możliwość schylenia się. Jednak głównym celem była możliwość przetransformowania się w robota jeżdżącego, co umowżliwiłoby wspinanie się po schodach oraz większych przeszkodach. Domyślnie w napędzie chciałem zastosować gąsienice.\n\n\n  \n  \n\n\n",
    "url": "/posts_pl/2014-08-28-universal-robots/"
  },
  
  {
    "title": "General-purpose robot",
    "excerpt": "\n",
    "content": "It was supposed to make coffee…\n\nThis is where my imagination got carried away and I wanted to make a multipurpose robot capable of performing various activities, e.g. prepare drinks, do the groceries. Of course, this was supposed to be the first version, on which I wanted to test my capabilities. It was to lift only dummies, and move only around the house.\n\n\n  \n  \n\n\nIt was a beautiful design and very complicated. I planned to use 11 servos to operate all the limbs. This greatly exceeded the number of PWM channels in the Atmega88Pa microcontroller. That is why I was forced to use software PWM generation, which puts much more load on the processor. It was for this reason that I was forced to use a second microcontroller responsible for communicating with the computer, controlling the motors, and setting servo positions to the second microcontroller via SPI. A lot of things could have gone wrong along the way, so when I finally couldn’t control the servos I didn’t know what was going on. Only after a long time did I come to the conclusion that I must have had a power supply that was too weak, something I hadn’t even considered before. However, despite the non-functioning servos, I did not abandon the design. I still had working motors that I could control from the computer. Then I took care of an essential element of such a robot - obstacle detection and mapping. For this purpose, I wanted to use stereo vision pair. After many experiments, I finally managed to bring the stereo vision to a satisfactory level. However, there was still a lot of noise - especially on the floor. Not surprisingly, the floor, the wall, is not much detail and it’s hard to get a reliable depth image. So it was more or less successful in detecting obstacles, but when it came to motion it was a completely different matter. The webcams used returned moving images which made the detection result even worse. I did not use encoders, because I planned to detect landmarks and later calculate the displacement based on them and the resulting depth map. However, after such disappointing stereo vision results I did not try this solution anymore.\n\n\n  \n  \n\n\nDespite the fact that it did not meet my expectations, it was an interesting construction. And my introduction to stereo vision and SLAM.\n\nPR2 was my inspiration for this robot. In the final version of this robot I wanted to make it 2 times larger. The use of a rotational joint in the waist was to increase the gripping range - the ability to bend down. However, the main goal was to be able to transform, which would enable it to climb stairs and larger obstacles. By default, I wanted to use tracks.\n\n\n  \n  \n\n\n",
    "url": "/posts_pl/2014-08-28-universal-robots_en/"
  },
  
  {
    "title": "3D Viewer",
    "excerpt": "Program służący do wyświetlania perspektywicznego punktów w 3D.\n\n\n",
    "content": "Program służący do wyświetlania perspektywicznego punktów w 3D.\n\n\n  \n  \n\n\nProgram ten napisałem w ramach lekcji Informatyki w Liceum. Zaimplementowałem wczytywanie chmur punktów z pliku txt. Są one w formacie współrzędne (X, Y, Z), a następnie kolory (R, G, B). Chmury punktów uzyskiwałem poprzez kamery stereowizyjne. Stworzyłem także możliwość wyświetlania kształtów geometrycznych, na przykład domku. Całość została napisana w Pascalu.\n\n\n  \n  \n\n\n3DViewer  github\n\n",
    "url": "/posts_pl/2015-04-09-3dviewer/"
  },
  
  {
    "title": "3D Viewer",
    "excerpt": "A piece of software for the perspective display of points in 3D.\n\n\n",
    "content": "A piece of software for the perspective display of points in 3D.\n\n\n  \n  \n\n\nI wrote this program as part of a Computer Science lesson in High School. I implemented the loading of point clouds from a txt file. They are in the format of coordinates (X, Y, Z) and colors (R, G, B). I obtained the point clouds through stereo vision camera. It is also possible to display geometric shapes, such as a house. The whole thing was written in Pascal.\n\n\n  \n  \n\n\n3DViewer  github\n\n",
    "url": "/posts_pl/2015-04-09-3dviewer_en/"
  },
  
  {
    "title": "Robot mapujący",
    "excerpt": "Robot laptopa wożący pokój mapujący.\n\n\n",
    "content": "Robot laptopa wożący pokój mapujący.\n\n\n  \n  \n\n\nTen robot jest drugą, uproszczoną wersją robota uniwersalnego. Wyciągając wnioski z poprzedniej konstrukcji uprościłem robota i jego jedynym zadaniem było mapowanie pomieszczeń. Także aby zadanie się udało zamieniłem Stereowizję na Kinecta, ponieważ rezultaty z niej osiągane nie były zadowalające. Dodałem także enkodery na koła, jednak wciąż zbyt pewny siebie zrobiłem swoje - inkrementalne bazujące na transoptorach. Nie sprawdzały się one idealnie, ale jednak pozwoliły osiągnąć rezultaty.\n\n\n  \n  Prototypowanie eletkroniki\n\n\nTakże w ramach zabawy z robotem zrealizowałem regulator PID i zadawałem punkt, do którego robot dojeżdżał.\n\nPID  github\n\n\n\n  \n  \n\n\nAby stworzyć mapę najpierw podrzebowałem odpowiednio obrobić dane. W danych głębi z Kinecta zawarte były informacje o podłodze oraz obiektach. Musiałem pozbyć się podłogi. Do osiągnięcia tego testowałem 2 metody: dopasowywanie płaszczyzny oparte na RANSACu z OpenCV oraz metodą UV-disparity, która przyspieszała obliczenia - wykrywałem linię zamiast płaszczyzny.\n\n\n  \n  \n\n\nNa tworzoną mapę typu Grid map nakładałem następnie wykryte obiekty. Do wyliczenia przesunięcia robota używałem wyłącznie enkoderów.\n\n  \n  \n\n\nMapowanie Kinect  github\n\n\n\n  \n  \n\n\nMapowanie Stereowizja  github\n\n\nPróbowałem także wykorzystać SLAMa, aby zniwelować niedoskonałości enkoderów. Jednak tutaj barierą był system operacyjny - Windows, na którym nie udało mi się uruchomić żadnej implementacji. Było to także zbyt skomplikowane zadanie jak na wiedzę, którą posiadałem, aby stworzyć własną implementację.\n\n\n  \n  \n\n\nDo sterowania robotem użyłem mikrokontrolera Atmega88Pa. Komunikował się on z komputerem poprzez interfejs UART, wykorzystałem tutaj przejściówkę na USB. Sterował on silnikami - serwami pracy ciągłej. Także mierzył napięcie z transoptorów, zliczając impulsy poprzez zastowanie odpowiedniego progu. Także dla testu wykorzystałem podczerwony czujnik odległości. Do zasilenia całej konstrukcji użyłem akumulatora żelowego. Poprzez mikrokontroler mierzyłem jego napięcie, sprawdzając czy się rozładował. Musiałem także zastosować przetwornicę Step-Up, aby zasilić Kinecta, który wymaga 12V.\n\nSterownik Robota  github\n\n",
    "url": "/posts_pl/2015-08-25-mapping-robot/"
  },
  
  {
    "title": "Mapping robot",
    "excerpt": "Robot that drives around and creates a map of the environment.\n\n\n",
    "content": "Robot that drives around and creates a map of the environment.\n\n\n  \n  \n\n\nThis robot is the second, simplified version of the general-purpose robot. Learning from the previous design, I simplified the robot and its only task was to map rooms. Also to make the task successful I replaced the Stereovision with Kinect, as the results from it were not satisfactory. I also added encoders to the wheels, but still I made my own - incremental based on optocouplers. They didn’t work perfectly, but still allowed to achieve good results.\n\n\n  \n  Prototypowanie eletkroniki\n\n\nAlso, as part of this project, I realized a PID controller and set a point which the robot would reach.\n\nPID  github\n\n\n\n  \n  \n\n\nAby stworzyć mapę najpierw podrzebowałem odpowiednio obrobić dane. W danych głębi z Kinecta zawarte były informacje o podłodze oraz obiektach. Musiałem pozbyć się podłogi. Do osiągnięcia tego testowałem 2 metody: dopasowywanie płaszczyzny oparte na RANSACu z OpenCV oraz metodą UV-disparity, która przyspieszała obliczenia - wykrywałem linię zamiast płaszczyzny.\n\n\n  \n  \n\n\nNa tworzoną mapę typu Grid map nakładałem następnie wykryte obiekty. Do wyliczenia przesunięcia robota używałem wyłącznie enkoderów.\n\n  \n  \n\n\nMapowanie Kinect  github\n\n\n\n  \n  \n\n\nMapowanie Stereowizja  github\n\n\nPróbowałem także wykorzystać SLAMa, aby zniwelować niedoskonałości enkoderów. Jednak tutaj barierą był system operacyjny - Windows, na którym nie udało mi się uruchomić żadnej implementacji. Było to także zbyt skomplikowane zadanie jak na wiedzę, którą posiadałem, aby stworzyć własną implementację.\n\n\n  \n  \n\n\nDo sterowania robotem użyłem mikrokontrolera Atmega88Pa. Komunikował się on z komputerem poprzez interfejs UART, wykorzystałem tutaj przejściówkę na USB. Sterował on silnikami - serwami pracy ciągłej. Także mierzył napięcie z transoptorów, zliczając impulsy poprzez zastowanie odpowiedniego progu. Także dla testu wykorzystałem podczerwony czujnik odległości. Do zasilenia całej konstrukcji użyłem akumulatora żelowego. Poprzez mikrokontroler mierzyłem jego napięcie, sprawdzając czy się rozładował. Musiałem także zastosować przetwornicę Step-Up, aby zasilić Kinecta, który wymaga 12V.\n\nSterownik Robota  github\n\n",
    "url": "/posts_pl/2015-08-25-mapping-robot_en/"
  },
  
  {
    "title": "Cewka Tesli",
    "excerpt": "Robi się groźnie.\n\n\n",
    "content": "Robi się groźnie.\n\n\n  \n  \n\n\nProjekt cewki tesli wykonany na podstawie \nElectroBoom\noraz\nLudic Science\n\n\n  \n  \n\n\nNajpierw wykonałem mniejszą wersję opartą na jednym tranzystorze, zasilaną baterią 9V.\n\n\n  \n  Nawijanie cewki\n\n\nNastępnie wykonałem cewkę o większych rozmiarach, w ktrórej zastosowałem 4 tranzystory oraz dodatkowy radiator, aby zapewnić odpowiednie chłodzenie. Jako źródło energii użyłem zasilacza od drukarki.\n",
    "url": "/posts_pl/2015-12-10-cewkatesli/"
  },
  
  {
    "title": "Efekt gitarowy Fuzz",
    "excerpt": "\n",
    "content": "\n  \n  \n\n\nEfekt gitarowy wykonany na podstawie schematu:\n\n  \n  \n\n\n\n  \n  \n\n",
    "url": "/posts_pl/2016-08-28-fuzz/"
  },
  
  {
    "title": "Świecąca kulka",
    "excerpt": "Obsługa komputera poprzez ruchy kontrolerem.\n\n\n",
    "content": "Obsługa komputera poprzez ruchy kontrolerem.\n\n\n  \n  \n\n\nKontroler zainspirowany rozwiązaniem z PlayStation. Użyłem kamerki internetowej oraz odpowiedniego kontrolera - latarki z kulką. Ruchy kulki są śledzone oraz przekładane na ruchy kursora myszy. Poprzez odpowiednie przygaszenie a następnie zaświecenie latarki symulowane jest kliknięcie.\n\nW celu analizy obrazu użyłem bibliotekę OpenCV oraz metodę wykrywania przedstawioną w https://forbot.pl/blog/opencv-2-wykrywanie-obiektow-id4888\n\n\n  \n  \n\n\nKod  github\n\n",
    "url": "/posts_pl/2017-05-26-move/"
  },
  
  {
    "title": "Hexapod",
    "excerpt": "Sześcionogi stwór z kamerkami.\n\n\n",
    "content": "Sześcionogi stwór z kamerkami.\n\nProjekt, którym zajmowałem się przez pierwsze 2 lata studiów w ramach działalności koła naukowego Integra. Moim wkładem było oprogramowanie do sterowania robota oraz stereowizji.\n\n\n  \n  \n\n\nDo poruszania konstrukcją wykorzystane zostało 18 serw Hitec po 3 na każdą nogę. Jako główny komputer robota wykorzystalismy Raspberry Pi 2. Komunikowała się ona z sterownikiem serw Pololu poprzez interfejs UART umożliwiając zadawanie odpowiednich pozycji serw. Całą konstrukcję zasila bateria LiPol o pojemności 4000 mAh, co pozwalało na ok. 1h użytkowania robota. Napięcie z akumulatora dostowywaliśmy za pomocą przetwornic (3 do zasilania serw oraz 1 dla Raspberry). Wykorzystaliśmy także przetwornik ADC MCP3008, aby móc mierzyć aktualne napięcie na baterii. Komunikował się on z Raspberry za pomocą SPI, a następnie napięcie było wysyłane i wyświetlane w aplikacji klienta.\n\n\n  \n  \n\n\nRobot jest sterowany z poziomu laptopa, który komunikuje się z Raspberry poprzez WiFi przez protokół TCP. Do poruszania robotem można używać zarówno pada jak i klawiatury. W celu odpowiedniego sterowania najpierw napisałem aplikację obrazującą model matematyczny robota. Na tym modelu została zaimplementowana kinematyka odwrotna, na której następnie stworzyłem modele poruszania się robota. Odpowiednio przeliczone uzyskane kąty na sygnały PWM dla serwonapędów były wysyłane do sterownika.\n\n\n  \n  \n\n\nSterowanie robotem\n\nAplikacja uruchamiana na laptopie zawiera wizualizacje modelu robota oraz odbiera sygnały sterowania od użytkownika, które następnie przekazuje do programu na Raspberry. On natomiast dokonuje odpowiednich przeliczeń na sygnały PWM, które następnie przekazuje do sterownika serw. Z Raspberry wysyłana jest także informacja zwrotna do aplikacji użytkownika z aktualnym napięciem na baterii, dzięki czemu jej poziom jest na bieżąco monitorowany. Osobny program służy do realizacji stereowizji. Raspberry wysyła obrazy z obu kamer przy użyciu programu gstreamer. Na laptopie oba obrazy są odbierane i następnie przy użyciu odpowiednich macierzy (uzyskanych podczas kalibracji) przekształcana oraz liczona jest macierz obrazu dysparcji. Zastosowałem także filtr po przeliczeniu dysparcji, który dodatkowo poprawia rezultaty.\n\nAplikacje modelu Hexapoda można pracować w 2 trybach:\n\nTryb modelu\n\nW trybie modelu można poruszać się po środowisku za pomocą klawiszy W/S/A/D/Q/E oraz barów alfa, beta i gamma służących do zmiany kąta widzenia. Modelem robota poruszać można za pomocą klawiszy w/s/a/d/q/e oraz numerów służących do wyboru odpowiedniego trybu chodzenia robota.\n\n\n  \n  \n\n\nTryb połączenia z Hexapodem\n\nUruchamia się jeśli dodatkowo przekażemy do programu przy uruchomieniu adres IP Raspberry. Sterowanie aplikacją na laptopie nie zmienia się. Różnica z poprzednio omówionym trybem (tryb modelu) jest taka, iż teraz odpowiednie komendy wysyłane są także do Hexapoda. Dodatkowo wyświetlane na ekranie laptopa jest również napięcie na baterii.\n\nBliższy opis elementów zrealizowanej aplikacji\n\nGUI\n\nZadaniem najbardziej oddalonym od samej idei Hexapoda był moduł wyświetlania, czyli GUI. Do wyświetlania użyto wyłącznie prostego okienkowego trybu wyświetlania dołączonego do biblioteki OpenCV w celu debugowania. Zastosowałem rzutowanie perspektywiczne zgodnie ze wzorami zawartymi w 1, aby otrzymać symulację w 3D. Zdefiniowałem płaszczyznę kamery, na którą odbywało się rzutowanie świata 3D symulacji. Dodałęm także przesuwanie płaszczyzną kamery za pomocą przycisków oraz możliwość jej obracania przy pomocy toolbarów.\n\nRobot\n\nTo jest główny moduł odpowiedzialny za obliczenia związane ze sterowaniem robota. Zawarłem w nim implementację kinematyki odwrotnej w podejściu trygonometrycznym opisaną w 2. Główna klasa robota zawiera klasę nóg robota, które są wydzielone. Jest osobna klasa, w której znajdują się różne algorytmy chodzenia.\n\nChodzenie\n\nNajlepsze efekty dawało chodzenie po paraboli. Dobierane są kolejne punkty paraboli, która zaczyna się w miejscu, gdzie aktualnie znajduje się końcówka nogi robota. Kończy się tam, gdzie ma się ostatecznie znaleźć. Przy użyciu kinematyki odwrotnej wyliczane są kąty tak, aby końcówka danej nogi znalazła się w punkcie docelowym.\n\nPozostałe moduły\n\nKontroler, który odpowiednio interpretuje wysłane komendy na funkcje, np.: chodzenia lub poruszania bazą robota. Znajduje się tutaj również moduł do komunikacji z serwami (tylko w wersji programu dla Raspberry). Zamieniane są wyliczone kąty dla każdej nogi na odpowiednie sygnały PWM, dla każdego serwa (jedna noga składa się z trzech serwonapędów). Następnie są one wysyłane.\n\nTCP\n\nW module TCP znajduję się cały kod do komunikacji pomiędzy Raspberry a laptopem. Kod został zaczerpnięty z 3. W ramach komunikacji laptop łączy się z Raspberry i na porcie 8081 odbiera aktualne napięcie baterii, które Raspberry stale udostępnia. Komunikacja w ramach odczytu napięcia baterii odbywa się w osobnym wątku, aby nie zakłócać pozostałych operacji. Natomiast na port 8080 aplikacja z laptopa wysyła podane komendy.\n\nAplikacja na laptopa  github\n\n\nAplikacja na Raspberry  github\n\n\nStereowizja\n\nPoniżej przedstawie krótki opis etapów realizacji stereowizji:\n\nWykonanie zdjęć kalibracyjnych\n\nAby skalibrować parę stereowizyjną wykonywane są zdjęcia ustalonego wzoru, np. szachownicy. W tym celu napisałem aplikację, która wyświetlała obraz z obu kamer. Co ustalony czas zapisywała zdjęcie pod odpowiednią nazwą oraz tworzyła listę utworzonych obrazów. Wykonałem około 50 zdjęć tak, aby jak najlepiej pokryć cały obszar widoku kamer.\n\n\n  \n  Przykładowa para zdjęć wykonanych podczas kalibracji\n\n\nWidoczny na zdjęciach zamieszczonych powyżej jest także następny napotkany problem - obiektywy w obudowach kamer zamontowane były nierówno. Oczywiście to przesunięcie eliminowane jest podczas kalibracji, jednak w rezultacie podczas właściwej stereowizji ograniczone jest pole widzenia od góry i dołu (część pixeli widoczna jest tylko przez jedną kamerkę).\n\nKalibracja\n\nDo samej kalibracji użyłem przykładu z książki Learning OpenCV. W parametrach wywołania umieszczano wysokość oraz szerokość szachownicy (liczba pól), a także długość boku kwadratu w centymetrach. Bardzo ważne jest, aby szachownica miała kwadratowe pola, gdyż przy użyciu szachownicy o bokach różniących się nieznacznie cały proces kalibracji zostałby przeprowadzony niepoprawnie wraz z listą zdjęć, powstałych w trakcie tej błędnej kalibracji.\n\n\n  \n  Wynik wykrywania krawędzi szachownicy\n\n\n\n  \n  Wynik rektyfikacji\n\n\nW wyniku działania kalibracji otrzymałem parametry zewnętrzne oraz wewnętrzne kamer, które następnie używane były do właściwej stereowizji. Uzyskano błędy:\nbłąd średniokwadratowy (RMS) = 0.0503053\nśredni błąd epipolarny = 0.517146\nSą to wartości niskie, co świadczy o poprawnie wykonanej kalibracji.\n\nWybór algorytmu oraz dobranie parametrów\n\nNajpierw przetestowałem dostępne w bibliotece OpenCV algorytmy BM i SGBM, lepsze rezultaty uzyskałem dla SGBM. Jest on bardziej wymagający obliczeniowo, aczkolwiek przy rozdzielczości 320x240 można było uzyskać dobre przetwarzanie w czasie rzeczywistym. Następnie dobrałem optymalne parametry dla tego algorytmu. W tym celu napisałem aplikację na podstawie przykładu użycia SGBM zawartego w bibliotece OpenCV. Dodałem do niej suwak tak, aby można było wygodnie zmieniać parametry i obserwować uzyskiwane rezultatu.\n\n\n  \n  Widok okna z paskami do zmiany parametrów\n\n\n\n  \n  Przykładowa scena użyta do doboru parametrów\n\n\n\n  \n  Wynik przeprowadzenia stereowizji\n\n\nDobranie parametrów dla postfiltracji\n\nW celu uzyskania gładszego obrazu stereowizyjnego zastosowałem postfiltrację, która dodana została stosunkowo niedawno do modułów dodatkowych biblioteki OpenCV - contrib.\n\n\n  \n  Efekt przeprowadzenia algorytmu SGBM przy optymalnych parametrach\n\n\n\n  \n  Efekt przeprowadzenia postfiltracji\n\n\nOstateczna aplikacja\n\nW ostatecznej aplikacji połączone zostały wszystkie opisane elementy. W wyniku czego otrzymano przesył obrazu z obu kamer na laptopa. Tam obraz był rektyfikowany, a pixele były dopasowywane za pomocą algorytmu SGBM. Przy użyciu posfiltracji obraz dysparcji jest poprawiany i na koniec wyświetlany. Dalszym etapem rozwojowym może być przeliczenie chmury punktów na podstawie dysparcji oraz następnie wykrywanie i omijanie przeszkód.\n\nPoza samą realizacją stereowizji ważnym elementem był także optymalny przesył obrazu z obu kamer. Pierwszym podejściem było użycie MJPGstreamera. Efekty jednak nie były zadowalające. Klatki, które nie zostały jeszcze wysłane, były składowane w buforze. W wyniku czego, im dłużej działała aplikacja, tym większe było opóźnienie. Dodatkowo występowała różnica czasu pomiędzy klatkami z obu kamer, co w przypadku stereowizji jest nieakceptowalne. Dlatego zdecydowano się użyć gstreamera. Jest on bardziej zaawansowany, przez co uruchomienie go zajęło więcej czasu. Jednak uzyskany efekt jest bardzo dobry. W jego działaniu, jeśli nie zdąży się wysłać klatki przed przybyciem następnej, to zostaje ona porzucona. W wyniku tego wyeliminowane zostało rosnące opóźnienie. Dlatego też nie występowało już opóźnienie pomiędzy klatkami. Rozdzielczość przesyłanych obrazów wynosi 320x240. Przeprowadzono także testy dla rozdzielczości 640x480, ale spadek FPS był nieproporcjonalny do wzrostu jakości.\n\nStereowizja  github\n\n\nOsiągnięcia\n\nZawody robotyczne\n\n\n  Robocomp 2017 w Krakowie (kategoria Freestyle)\n  Robotic Arena 2017 we Wrocławiu (kategorie Freestyle oraz wyścig robotów kroczących). Pierwsze miejsce w kategorii wyścig robotów kroczących.\n  Robomaticon 2018 w Warszawie (kategoria Freestyle)\n  Robotic Tournament 2018 w Rybniku (kategoria Freestyle)\n  Robotic Arena 2019 we Wrocławiu. Drugie miejsce w kategorii wyścig robotów kroczących.\n\n\nWydarzenia\n\n\n  Targi pracy Kariera IT\n  TEDxAGHUniversity\n\n\n\n  \n  Prezentacja na zawodach Robotic Arena fot. Politechnika Wrocławska\n\n\nStrona projektu\n",
    "url": "/posts_pl/2018-06-08-hexapod/"
  },
  
  {
    "title": "Hexapod",
    "excerpt": "\n",
    "content": "A project I was involved in for the first 2 years of my studies as part of the Integra student research group. My contribution was software for robot control and stereovision.\n\n\n  \n  \n\n\nTo move robot uses 18 Hitec servos, 3 for each leg. We used a Raspberry Pi 2 as the robot’s main computer, it communicated with the Pololu servo controller via a UART interface, which set servo positions. The entire design was powered by a 4000 mAh LiPol battery, which allowed the robot to be used for about 1h. We supplied voltage from the battery using voltage converters (3 to power the servos and 1 for the Raspberry). We also used an ADC MCP3008 to measure voltage on the battery. It communicated with the Raspberry via SPI, and then the voltage was sent and displayed in the client application.\n\n\n  \n  \n\n\nThe robot is controlled from a laptop, which communicates with the Raspberry via WiFi via TCP protocol. Both a pad and a keyboard can be used to move the robot. In order to properly control it, I first wrote an application with a mathematical model of the robot. Inverse kinematics was implemented on this model, on which I then created models of the robot’s movement. The obtained angles were then converted into PWM signals and sent to servos through controller.\n\n\n  \n  \n\n\nControlling the robot\n\nThe application running on the laptop contains visualizations of the robot model and receives control signals from the user, which it then sent to the program on the Raspberry. It makes the appropriate conversions to PWM signals, which are sent to the servo controller. Feedback is also sent from the Raspberry to the user application with the current voltage on the battery, so that its level is monitored in real time. A separate program is used to implement stereovision. The Raspberry sends images from both cameras using the gstreamer. On the laptop, both images are received and then using the appropriate matrices (obtained during calibration) the disparity image matrix is transformed and calculated. I also applied a filter after the disparity conversion, which further improves the results.\n\nHexapod model applications can work in 2 modes:\n\nModel mode\n\nIn model mode, you can move around the environment using the W/S/A/D/Q/E keys and the alpha, beta and gamma bars for changing the viewing angle. The robot model can be moved using the w/s/a/d/q/e keys and the numbers used to select the appropriate robot walking mode.\n\n\n  \n  \n\n\nHexapod connection mode\n\nIt runs if you additionally pass the IP address of the Raspberry to the program at startup. The control of the application on the laptop does not change. The difference with the previously discussed mode (model mode) is that now the corresponding commands are also sent to the Hexapod. Additionally the voltage on the battery is also displayed on the laptop screen.\n\nA more detailed description of the elements of the realized application\n\nGUI\n\nZadaniem najbardziej oddalonym od samej idei Hexapoda był moduł wyświetlania, czyli GUI. Do wyświetlania użyto wyłącznie prostego okienkowego trybu wyświetlania dołączonego do biblioteki OpenCV w celu debugowania. Zastosowałem rzutowanie perspektywiczne zgodnie ze wzorami zawartymi w 1, aby otrzymać symulację w 3D. Zdefiniowałem płaszczyznę kamery, na którą odbywało się rzutowanie świata 3D symulacji. Dodałęm także przesuwanie płaszczyzną kamery za pomocą przycisków oraz możliwość jej obracania przy pomocy toolbarów.\n\nRobot\n\nTo jest główny moduł odpowiedzialny za obliczenia związane ze sterowaniem robota. Zawarłem w nim implementację kinematyki odwrotnej w podejściu trygonometrycznym opisaną w 2. Główna klasa robota zawiera klasę nóg robota, które są wydzielone. Jest osobna klasa, w której znajdują się różne algorytmy chodzenia.\n\nChodzenie\n\nNajlepsze efekty dawało chodzenie po paraboli. Dobierane są kolejne punkty paraboli, która zaczyna się w miejscu, gdzie aktualnie znajduje się końcówka nogi robota. Kończy się tam, gdzie ma się ostatecznie znaleźć. Przy użyciu kinematyki odwrotnej wyliczane są kąty tak, aby końcówka danej nogi znalazła się w punkcie docelowym.\n\nPozostałe moduły\n\nKontroler, który odpowiednio interpretuje wysłane komendy na funkcje, np.: chodzenia lub poruszania bazą robota. Znajduje się tutaj również moduł do komunikacji z serwami (tylko w wersji programu dla Raspberry). Zamieniane są wyliczone kąty dla każdej nogi na odpowiednie sygnały PWM, dla każdego serwa (jedna noga składa się z trzech serwonapędów). Następnie są one wysyłane.\n\nTCP\n\nW module TCP znajduję się cały kod do komunikacji pomiędzy Raspberry a laptopem. Kod został zaczerpnięty z 3. W ramach komunikacji laptop łączy się z Raspberry i na porcie 8081 odbiera aktualne napięcie baterii, które Raspberry stale udostępnia. Komunikacja w ramach odczytu napięcia baterii odbywa się w osobnym wątku, aby nie zakłócać pozostałych operacji. Natomiast na port 8080 aplikacja z laptopa wysyła podane komendy.\n\nAplikacja na laptopa  github\n\n\nAplikacja na Raspberry  github\n\n\nStereowizja\n\nPoniżej przedstawie krótki opis etapów realizacji stereowizji:\n\nWykonanie zdjęć kalibracyjnych\n\nAby skalibrować parę stereowizyjną wykonywane są zdjęcia ustalonego wzoru, np. szachownicy. W tym celu napisałem aplikację, która wyświetlała obraz z obu kamer. Co ustalony czas zapisywała zdjęcie pod odpowiednią nazwą oraz tworzyła listę utworzonych obrazów. Wykonałem około 50 zdjęć tak, aby jak najlepiej pokryć cały obszar widoku kamer.\n\n\n  \n  Przykładowa para zdjęć wykonanych podczas kalibracji\n\n\nWidoczny na zdjęciach zamieszczonych powyżej jest także następny napotkany problem - obiektywy w obudowach kamer zamontowane były nierówno. Oczywiście to przesunięcie eliminowane jest podczas kalibracji, jednak w rezultacie podczas właściwej stereowizji ograniczone jest pole widzenia od góry i dołu (część pixeli widoczna jest tylko przez jedną kamerkę).\n\nKalibracja\n\nDo samej kalibracji użyłem przykładu z książki Learning OpenCV. W parametrach wywołania umieszczano wysokość oraz szerokość szachownicy (liczba pól), a także długość boku kwadratu w centymetrach. Bardzo ważne jest, aby szachownica miała kwadratowe pola, gdyż przy użyciu szachownicy o bokach różniących się nieznacznie cały proces kalibracji zostałby przeprowadzony niepoprawnie wraz z listą zdjęć, powstałych w trakcie tej błędnej kalibracji.\n\n\n  \n  Wynik wykrywania krawędzi szachownicy\n\n\n\n  \n  Wynik rektyfikacji\n\n\nW wyniku działania kalibracji otrzymałem parametry zewnętrzne oraz wewnętrzne kamer, które następnie używane były do właściwej stereowizji. Uzyskano błędy:\nbłąd średniokwadratowy (RMS) = 0.0503053\nśredni błąd epipolarny = 0.517146\nSą to wartości niskie, co świadczy o poprawnie wykonanej kalibracji.\n\nWybór algorytmu oraz dobranie parametrów\n\nNajpierw przetestowałem dostępne w bibliotece OpenCV algorytmy BM i SGBM, lepsze rezultaty uzyskałem dla SGBM. Jest on bardziej wymagający obliczeniowo, aczkolwiek przy rozdzielczości 320x240 można było uzyskać dobre przetwarzanie w czasie rzeczywistym. Następnie dobrałem optymalne parametry dla tego algorytmu. W tym celu napisałem aplikację na podstawie przykładu użycia SGBM zawartego w bibliotece OpenCV. Dodałem do niej suwak tak, aby można było wygodnie zmieniać parametry i obserwować uzyskiwane rezultatu.\n\n\n  \n  Widok okna z paskami do zmiany parametrów\n\n\n\n  \n  Przykładowa scena użyta do doboru parametrów\n\n\n\n  \n  Wynik przeprowadzenia stereowizji\n\n\nDobranie parametrów dla postfiltracji\n\nW celu uzyskania gładszego obrazu stereowizyjnego zastosowałem postfiltrację, która dodana została stosunkowo niedawno do modułów dodatkowych biblioteki OpenCV - contrib.\n\n\n  \n  Efekt przeprowadzenia algorytmu SGBM przy optymalnych parametrach\n\n\n\n  \n  Efekt przeprowadzenia postfiltracji\n\n\nOstateczna aplikacja\n\nW ostatecznej aplikacji połączone zostały wszystkie opisane elementy. W wyniku czego otrzymano przesył obrazu z obu kamer na laptopa. Tam obraz był rektyfikowany, a pixele były dopasowywane za pomocą algorytmu SGBM. Przy użyciu posfiltracji obraz dysparcji jest poprawiany i na koniec wyświetlany. Dalszym etapem rozwojowym może być przeliczenie chmury punktów na podstawie dysparcji oraz następnie wykrywanie i omijanie przeszkód.\n\nPoza samą realizacją stereowizji ważnym elementem był także optymalny przesył obrazu z obu kamer. Pierwszym podejściem było użycie MJPGstreamera. Efekty jednak nie były zadowalające. Klatki, które nie zostały jeszcze wysłane, były składowane w buforze. W wyniku czego, im dłużej działała aplikacja, tym większe było opóźnienie. Dodatkowo występowała różnica czasu pomiędzy klatkami z obu kamer, co w przypadku stereowizji jest nieakceptowalne. Dlatego zdecydowano się użyć gstreamera. Jest on bardziej zaawansowany, przez co uruchomienie go zajęło więcej czasu. Jednak uzyskany efekt jest bardzo dobry. W jego działaniu, jeśli nie zdąży się wysłać klatki przed przybyciem następnej, to zostaje ona porzucona. W wyniku tego wyeliminowane zostało rosnące opóźnienie. Dlatego też nie występowało już opóźnienie pomiędzy klatkami. Rozdzielczość przesyłanych obrazów wynosi 320x240. Przeprowadzono także testy dla rozdzielczości 640x480, ale spadek FPS był nieproporcjonalny do wzrostu jakości.\n\nStereowizja  github\n\n\nOsiągnięcia\n\nZawody robotyczne\n\n\n  Robocomp 2017 w Krakowie (kategoria Freestyle)\n  Robotic Arena 2017 we Wrocławiu (kategorie Freestyle oraz wyścig robotów kroczących). Pierwsze miejsce w kategorii wyścig robotów kroczących.\n  Robomaticon 2018 w Warszawie (kategoria Freestyle)\n  Robotic Tournament 2018 w Rybniku (kategoria Freestyle)\n  Robotic Arena 2019 we Wrocławiu. Drugie miejsce w kategorii wyścig robotów kroczących.\n\n\nWydarzenia\n\n\n  Targi pracy Kariera IT\n  TEDxAGHUniversity\n\n\n\n  \n  Prezentacja na zawodach Robotic Arena fot. Politechnika Wrocławska\n\n\nStrona projektu\n",
    "url": "/posts_pl/2018-06-08-hexapod_en/"
  },
  
  {
    "title": "Czołg",
    "excerpt": "Pojazd uniwersalny oparty o Raspberry Pi Zero.\n\n\n",
    "content": "Pojazd uniwersalny oparty o Raspberry Pi Zero.\n\n\n  \n  \n\n\nUmożliwia obserwację obrazu z kamerki, odczyt napięcia na baterii (poziom rozładowania ), temperatury z Raspberry oraz wartości enkoderów. Dotychczas odczytów z enkoderów nie wykorzystałem w sposób praktyczny, jednak zamieszczenie ich umożliwi dalszy rozwój konstrukcji.\n\n\n  \n  \n\n\nProjekt ten zaczął się od płytki PCB.\n\n  \n  Płytka wraz z podłączonymi wszystkimi elementami\n\n\nMiała być wykorzystana do sterowania robotem z następującymi elementami:\n\n\n  dwa silniki z enkoderami\n  trzy serwa\n  komunikacja z Raspberry pooprzez SPI\n  pomiar napięcia z baterii\n  dwa LEDy ( uruchomienie oraz rozładowanie)\n\n\n\n  \n  Złożony schemat prototypowany na płytce stykowej\n\n\nJako źródło zasilania wykorzystałem LiPola oraz 2 przetwornicę: jedną do logigki oraz drugą do serw. W trakcie realizacji projektu jednak zorientowałem się, że ten mikrokontroler jest za słaby. Było to spowodowane tym, że potrzebowałem 3 kanałów PWM do serw oraz 2 do sterowania prędkością silników. Nie miałem jednak dostępnej takiej liczby, dlatego sygnały PWM dla serw musiałem generować programowo, przez co znacznie wzrosło obciążenie procesora. Doliczając do tego bardzo często przerwania zewnętrzne z dwóch enkoderów, nie byłem w stanie dostarczyć wystarczająco dokładnego przebiegu PWM by sterować serwami. Dlatego ostatecznie pominąłem użycie serw w tym projekcie.\n\n\n  \n  \n\n\nKonstrukcja czołgu została wykonana na drukarce 3D, a jej projekt zaczerpnąłem z\nhttps://www.thingiverse.com/thing:652851\n\n\n  \n  Płytka po wytrawieniu\n\n\nRobotem steruje się poprzez przeglądarkę. W tym celu użyłem skryptu z https://hackaday.io/project/25092-zerobot-raspberry-pi-zero-fpv-robot/log/97988-the-new-zerobot-pro\n,który odpowiednio przerobiłem do swoich potrzeb ( zamiana sterowania na takie wykorzystujące SPI).\n\nProjekt  github\n\n",
    "url": "/posts_pl/2019-03-27-tank/"
  },
  
  {
    "title": "Tank",
    "excerpt": "\n",
    "content": "General purpose platform based on Raspberry Pi Zero.\n\n\n  \n  \n\n\nIt allows you to observe the image from the camera, read the voltage on the battery (discharge level ), the temperature from the Raspberry and the values of the encoders. So far I have not used the encoder readings in a practical way, but including them will enable further development of the design.\n\n\n  \n  \n\n\nThis project started with PCB.\n\n  \n  PCB with all components\n\n\nIt was supposed to be used to control a robot with the following components:\n\n\n  two motors with encoders\n  three servos\n  communication with Raspberry via SPI\n  voltage measurement from the battery\n  two LEDs (startup and discharge)\n\n\n\n  \n  Złożony schemat prototypowany na płytce stykowej\n\n\nI used LiPol as the power source and 2 voltage converters: one for the logic and the other for the servos. During the realization of the project, however, I realized that the microcontroller was too weak. The reason was that I needed 3 PWM channels for the servos and 2 for controlling the speed of the motors. However, I didn’t have that number available, so I had to generate the PWM signals for the servos by software, which significantly increased the load on the processor. Additionally very frequent external interrupts from the two encoders made it impossible to provide a sufficiently accurate PWM waveform to control the servos. Therefore I skipped the use of servos in this project.\n\n\n  \n  \n\n\nThe tank construction was made on a 3D printer, and I used the design from\nhttps://www.thingiverse.com/thing:652851\n\n\n  \n  Płytka po wytrawieniu\n\n\nThe robot is controlled through a browser. For this purpose, I used a script from https://hackaday.io/project/25092-zerobot-raspberry-pi-zero-fpv-robot/log/97988-the-new-zerobot-pro\n,which I appropriately converted to my needs ( swapping the control to one using SPI).\n\nProjekt  github\n\n",
    "url": "/posts_pl/2019-03-27-tank_en/"
  },
  
  {
    "title": "Human following robot",
    "excerpt": "Every move you make |\nEvery step you take |\nI’ll follow you\n\n\n",
    "content": "In this tutorial I describe one way to make robot detect and follow people - it won’t make a great spy but could be useful to carry luggage or groceries. Whole system was implemented on Husarion’s ROSbot with ESP32 as a remote. To find people I used scans from LiDAR (RPLidar A2) with my detector, which is simple but turned out to be fast and quite reliable. I also checked other LiDAR approaches available on ROS - leg_detector and leg_tracker but in this case didn’t perform well enough. Another package I tested is upper_body_detector, which uses RGBD camera to detect humans. As name suggests it needs to see upper part of body - this will be a problem if we want our robot to stay close, also in this case it didn’t perform very well and was slower.\n\n\n  \n  \n\n\nSetup\n\nESP32 Remote\n\nEnvironment\n\nYou will need to follow tutorial about setting up rosserial connection over Internet with ESP32. On ROSbot prepare Husarnet connection and Rosserial for Husarnet. I recommend to set up Arduino IDE on your computer (remember to also get Rosserial for Husarnet).\n\nCode\n\nCreate new sketch in Arduino IDE and copy code:\nESP Remote Code\n\nThen get your Husarnet join code and customize code as described in ESP32 Husarnet Tutorial\n\nWiring\n\nWire your ESP32 accordingly to schematics:\n\n\n  \n  \n\n\nAs a source of power you can use a Powerbank connected to the ESP.\n\nROSbot\n\nThis project is meant to run on CORE2 with Mbed firmware. So be sure that you updated your firmware as described in ROSbot quick start. On ROSbot you will need to install following dependencies:\n\n\n  scikit-learn python library (for clusterization)\n    sudo apt-get install python-scikits-learn\n    \n  \n  \n    pykalman\nFollow installation tutorial on pykalman page\n  \n  rosbot_description package (for URDF visualization model and bridge node)\nGo to your ROS workspace and clone repository:\n    cd ~/ros_workspace/src\ngit clone https://github.com/husarion/rosbot_description.git\n    \n    Install dependencies:\n    cd ~/ros_workspace\nrosdep install --from-paths src --ignore-src -r -y\n    \n  \n  rosbot_ekf\nInstall dependency:\n    sudo apt-get install ros-kinetic-robot-localization\n    \n    Get package:\n    git clone https://github.com/byq77/rosbot_ekf.git\n    \n  \n\n\nThen go back to src folder in your workspace:\n\ncd ~/ros_workspace/src\n\n\nDownload code:\n\ngit clone https://github.com/macstepien/rosbot_follower.git\n\n\nAnd finally build your workspace:\n\ncd ~/ros_workspace\ncatkin_make\n\n\nUsage\n\nThere are two options available:\n\n\n  followerSlow - better if you have little space and walk slowly.\nTo run it you only need to copy this commande into new terminal window:\n    roslaunch rosbot_follower followerSlow.launch\n    \n  \n  followerKalman - this one should be able to follow you with normal walking, but it also needs some space to gain speed.\nRoslaunch command:\n    roslaunch rosbot_follower followerKalman.launch\n    \n  \n\n\nAfter whole system is up and running stand in front of ROSbot, but not too far away. When you are detected blue LED on ESP should turn on. Then you can press first button (the one closer to ESP on schematics) and if you start walking robot should follow you. When LED turns off it means that algorithm lost detection of you and need to recalibrate (stand closer to robot and wait until blue LED is back on). If robot had false detection you can calibrate again by pressing second button. On RViz you can see visualization: scan from LiDAR, robot model and detections. Green spheres are all potential legs, blue cylinders are detected legs and red tall cylinder is human position. In version with Kalman filter we also publish circle around human, which shows how much estimated position differs from measurement.\n\n\n  \n  \n\n\nTroubleshooting\n\n\n  LED doesn’t turn on - check RViz if you can see detected human (red cylinder). If there is a detection then press Dead Man’s Button and try to walk.\n  ROSbot doesn’t respond - you should check your connection to ESP32. You can do so by echoing button topic:\n    rostopic echo /esp_remote/start\n    \n    If nothing can be seen, try restarting your ESP by turning it off and on again.\n  \n\n\nAlgorithm walkthrough\n\nFirst we will go through slower version, as it is simpler. Main part of this code is scan callback where all the magic happens - data from LiDAR is analyzed and people are detected. Whole process consists of 5 steps:\n\n\n  Clusterization\n  Leg detection\n  Human detection\n  Marker publishing\n  Control\n\n\n1. Clusterization\n\ndef scanCallback(self, scan):\n    clusterList = self.findClusters(scan)\n    ...\n\n\nFirst we find clusters in our scan using Euclidean Clusterization Algorithm:\n\ndef findClusters(self, scan):\n    pointsList = np.zeros((0, 2))\n    i = 0\n    for r in scan.ranges:\n        if r &gt; self.minRange and r &lt; self.maxRange:\n            alfa = scan.angle_min + i * scan.angle_increment\n            x = r * math.cos(alfa)\n            y = r * math.sin(alfa)\n            if (alfa &gt; -math.pi and alfa &lt; -self.maxAngle) or \\\n                (alfa &gt; self.maxAngle and alfa &lt; math.pi):\n                pointsList = np.append(pointsList, [[x, y]], axis=0)\n        elif r &lt; self.minRange:\n            rospy.logerr(\"Obstacle detected\")\n            return [np.zeros((1, 2))]\n        i += 1\n    db = DBSCAN(eps=self.clusterizationMaxDistanceParam,\n                min_samples=self.clusterizationMinSamplesParam).fit(pointsList)\n    core_samples_mask = np.zeros_like(db.labels_, dtype=bool)\n    core_samples_mask[db.core_sample_indices_] = True\n    labels = db.labels_\n    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)\n    unique_labels = set(labels)\n    clusterList = []\n    for k in unique_labels:\n        class_member_mask = (labels == k)\n        xy = pointsList[class_member_mask &amp; core_samples_mask]\n        if xy.any():\n            clusterList.append(xy)\n    return clusterList\n\n\nHere we have few parameters that you can customize:\n\n\n  minRange - used to filter ranges from lidar points, if anything gets closer than that, then ROSbot treats it as obstacle and stops\n  maxRange - data from lidar further than that value are dismissed\n  maxAngle - readings have to be in front of ROSbot in ranges (maxAngle, Pi) u (-Pi, -maxAngle)\n  clusterizationMaxDistanceParam - maximum distance between points to add new point to cluster\n  clusterizationMinSamplesParam - minimum number of points in cluster\n\n\nMore information about DBSCAN clusterization\n\nBack to scanCallback:\n\ndef scanCallback(self, scan):\n    ...\n    if len(clusterList) == 0:\n    \trospy.logwarn(\"No clusters detected\")\n    \tif rospy.get_time() - self.lastDetectionTime &lt; self.detectionTimeout:\n            humanPosition = self.lastHumanPosition\n            self.controlRosbot(humanPosition)\n    \telse:\n            led = Bool()\n            led.data = False\n            self.ledPub.publish(led)\n            self.positionCalibration = True\n            rosbotControl = Twist()\n            self.speedPub.publish(rosbotControl)\n    \treturn\n    elif (clusterList[0][0, 0] == 0) and (clusterList[0][0, 1] == 0):\n    \tled = Bool()\n    \tled.data = False\n    \tself.ledPub.publish(led)\n    \tself.positionCalibration = True\n    \trosbotControl = Twist()\n    \tself.speedPub.publish(rosbotControl)\n    \treturn\n    ...\n\n\nIn here we check results of clusterization. If we didn’t detect anything, we continue movement in last seen human position. That is until our last seen position is too old - then we need to stop and assume we lost track of our human, which we signal through LED.\nWe pass special value when obstacle is detected - in first cluster first point is set to (0,0). In this case robot needs to stop immediately, as obstacle is too close.\n\n\n  detectionTimeout - how much time (in seconds) we can trust last seen position and follow it\n\n\n2. Leg detection\n\nNext step is leg detection:\n\ndef scanCallback(self, scan):\n    ...\n    sortedClusters = self.detectLegs(clusterList)\n    ...\n\n\ndef detectLegs(self, clusterList):\n    i = 0\n    sortedClusters = []\n    for cluster in clusterList:\n    \txMax = np.max(cluster[:, 0])\n    \txMin = np.min(cluster[:, 0])\n    \tyMax = np.max(cluster[:, 1])\n    \tyMin = np.min(cluster[:, 1])\n    \txDistance = xMax - xMin\n    \tyDistance = yMax - yMin\n    \tproportion = max(xDistance,yDistance)/min(xDistance, yDistance)\n    \tarea = xDistance*yDistance\n    \tif not (max(xDistance,yDistance)-self.legWidth) &lt; self.dLegWidth:\n    \t\tcontinue\n    \txMean = (xMax+xMin)/2\n    \tyMean = (yMax+yMin)/2\n    \tcone = Point()\n    \tcone.x = xMean\n    \tcone.y = yMean\n    \tcone.z = 0\n    \tsortedClusters.append(cone)\n    sortedClusters.sort(key=lambda x: math.sqrt(x.x**2 + x.y**2))\n    return sortedClusters\n\n\nIn this section we go through each cluster and calculate its bounding rectangle. Then we filter our data with following rule: longer side of rectangle can have maximal length of legWidth + dLegWidth (meaning that we assume leg width of legWidth with upper toleration dLegWidth). I encourage you to experiment with it and maybe try other conditions e.g. area and sides proportions. If cluster passes we find its centroid and save it for further calculations. As last thing we sort our potential legs by distance from ROSbot.\n\n\n  legWidth - width of the leg\n  dLegWidth - toleration of leg width\n\n\ndef scanCallback(self, scan):\n    ...\n    if len(sortedClusters) == 0:\n    \trospy.logwarn(\"No legs detected\")\n    \tif rospy.get_time() - self.lastDetectionTime &lt; self.detectionTimeout:\n            humanPosition = self.lastHumanPosition\n            self.controlRosbot(humanPosition)\n    \telse:\n            led = Bool()\n            led.data = False\n            self.ledPub.publish(led)\n            self.positionCalibration = True\n            rosbotControl = Twist()\n            self.speedPub.publish(rosbotControl)\n    \treturn\n    ...\n\n\nSimilar to previous step we check results of leg detection. No legs found - we allow ROSbot to move for some time. This step is necessary to smooth out movement - sometimes in only one frame we don’t detect any legs, which can cause robot to stop and go.\n\n3. Human detection\n\nWe estimate human position through analysis of legs detections:\n\ndef scanCallback(self, scan):\n    ...\n    (firstLeg, secondLeg, humanPosition, firstLegDetected, twoLegsDetected) = self.detectHuman(sortedClusters)\n    ...\n\n\ndef detectHuman(self, sortedClusters):\n    firstLeg = sortedClusters[0]\n    firstLegDetected = False\n    twoLegsDetected = False\n    secondLeg = Point()\n    humanPosition = Point()\n    humanPositionTemp = Point()\n    if len(sortedClusters) &gt; 2:\n    \tsortedClusters.sort(key=lambda x: math.sqrt((x.x-firstLeg.x)**2 + (x.y-firstLeg.y)**2))\n    \tsecondLeg = sortedClusters[1]\n    \tlegDistance = math.sqrt((firstLeg.x - secondLeg.x)**2 + (firstLeg.y - secondLeg.y)**2)\n    \tif legDistance &lt; self.legDistanceThreshold:\n            humanPositionTemp.x = (firstLeg.x+secondLeg.x)/2\n            humanPositionTemp.y = (firstLeg.y+secondLeg.y)/2\n            humanPositionTemp.z = 0\n            twoLegsDetected = True\n    \telse:\n            humanPositionTemp = firstLeg\n    else:\n    \thumanPositionTemp = firstLeg\n    if self.positionCalibration:\n    \tr = math.sqrt( humanPositionTemp.x ** 2 + humanPositionTemp.y ** 2)\n    \tif r &lt; self.calibrationDistance and twoLegsDetected:\n            self.lastHumanPosition = humanPositionTemp\n            humanPosition = humanPositionTemp\n            firstLegDetected = True\n            self.lastDetectionTime = rospy.get_time()\n            self.positionCalibration = False\n            led = Bool()\n            led.data = True\n            self.ledPub.publish(led)\n    else:\n    \tdistanceChange = math.sqrt((self.lastHumanPosition.x - humanPositionTemp.x)**2 \\\n    \t\t\t\t+ (self.lastHumanPosition.y - humanPositionTemp.y)**2)\n    \tif distanceChange &lt; self.humanPositionChangeThreshold:\n            humanPosition = humanPositionTemp\n            firstLegDetected = True\n            self.lastHumanPosition = humanPosition\n            self.lastDetectionTime = rospy.get_time()\n    \telse:\n            if rospy.get_time() - self.lastDetectionTime &lt; self.detectionTimeout:\n                humanPosition = self.lastHumanPosition\n            else:\n                led = Bool()\n                led.data = False\n                self.ledPub.publish(led)\n                self.positionCalibration = True\n    return (firstLeg, secondLeg, humanPosition, firstLegDetected, twoLegsDetected)\n\n\nWe assume our first detected leg is one closest to ROSbot. Second leg (if any available) is one closest to first leg (if it’s close enough). With two legs detected we calculate possible human position as mean between legs, otherwise we use first leg as possible human position.\nWhen human position is not calibrated, then two legs have to be visible in range closer than given threshold. Provided that our position is already calibrated, we can check if our detected human position is viable. We calculate difference in positions between new and old detection, too big value means that it’s probably false detection. In this case we check if we can use older position, otherwise we lost track of human position.\n\n\n  legDistanceThreshold - maximum distance from first leg to second leg, if second leg distance is more than that, we use only first leg detection\n  calibrationDistance - maximum distance from human to ROSbot to initialize position\n  humanPositionChangeThreshold - maximum distance between last detected human position and recent human position\n  detectionTimeout - how much time we can use old detection as human position, if we exceed this time we consider that we lost our human detection\n\n\n4. Marker publishing\n\nVisualization of our detections\n\ndef scanCallback(self, scan):\n    ...\n    self.publishMarkers(firstLeg, secondLeg, humanPosition, firstLegDetected, twoLegsDetected, sortedClusters)\n    ...\n\n\ndef publishMarkers(self, firstLeg, secondLeg, humanPosition, firstLegDetected, twoLegsDetected, sortedClusters):\n    legMarker = Marker()\n    legMarker.header.frame_id = \"laser\"\n    legMarker.ns = \"person\"\n    legMarker.header.stamp = rospy.Time()\n    legMarker.type = Marker.CYLINDER\n    legMarker.action = Marker.ADD\n    legMarker.pose.orientation.x = 0.0\n    legMarker.pose.orientation.y = 0.0\n    legMarker.pose.orientation.z = 0.0\n    legMarker.pose.orientation.w = 1.0\n    legMarker.scale.x = 0.04\n    legMarker.scale.y = 0.04\n    legMarker.scale.z = 0.04\n    legMarker.color.a = 1.0\n    legMarker.color.r = 0.0\n    legMarker.color.g = 0.0\n    legMarker.color.b = 1.0\n    legMarker.lifetime = rospy.Duration(0.5)\n    if not self.positionCalibration:\n    \t#first leg\n        if firstLegDetected:\n            legMarker.id = 1\n            legMarker.pose.position = firstLeg\n            legMarker.pose.position.z = 0.02\n            self.legPub.publish(legMarker)\n        #second leg\n        if twoLegsDetected:\n            legMarker.id = 2\n            legMarker.pose.position = secondLeg\n            self.legPub.publish(legMarker)\n    \t#human position\n    \tlegMarker.id = 3\n    \tlegMarker.scale.z = 0.2\n    \tlegMarker.pose.position = humanPosition\n    \tlegMarker.pose.position.z = 0.1\n    \tlegMarker.color.r = 1.0\n    \tlegMarker.color.b = 0.0\n    \tself.legPub.publish(legMarker)\n    legMarker = Marker()\n    legMarker.ns = \"legs\"\n    legMarker.header.frame_id = \"laser\"\n    legMarker.header.stamp = rospy.Time()\n    legMarker.type = Marker.SPHERE\n    legMarker.action = Marker.ADD\n    legMarker.pose.orientation.x = 0.0\n    legMarker.pose.orientation.y = 0.0\n    legMarker.pose.orientation.z = 0.0\n    legMarker.pose.orientation.w = 1.0\n    legMarker.scale.x = 0.04\n    legMarker.scale.y = 0.04\n    legMarker.scale.z = 0.04\n    legMarker.color.a = 1.0\n    legMarker.color.r = 0.0\n    legMarker.color.g = 1.0\n    legMarker.color.b = 0.0\n    legMarker.lifetime = rospy.Duration(0.2)\n    i = 1\n    for x in sortedClusters:\n    \tlegMarker.id = i\n    \ti += 1\n    \tlegMarker.pose.position.x = x.x\n    \tlegMarker.pose.position.y = x.y\n    \tself.legPub.publish(legMarker)\n\n\nPretty straightforward: we publish markers with potential legs (green spheres), detected legs (if any found, blue cylinders) and human (red cylinder).\n\n5. Control\n\nAnd final step is movement control:\n\ndef scanCallback(self, scan):\n    ...\n    self.controlRosbot(humanPosition)\n\n\ndef controlRosbot(self, humanPosition):\n    r = math.sqrt( humanPosition.x ** 2 + humanPosition.y ** 2)\n    a = math.atan2(humanPosition.y, -humanPosition.x)\n    if r &gt; self.minHumanDistance:\n    \txSpeed = -r * self.speedPGain\n    else:\n    \txSpeed = 0\n    if abs(a) &gt; self.minHumanAngle:\n    \tzAngularSpeed = a * self.angularSpeedPGain\n    else:\n    \tzAngularSpeed = 0\n    rosbotControl = Twist()\n    if rospy.get_time() - self.buttonTime &lt; self.buttonTimeout and \\\n    \t\tself.buttonState == True and not self.positionCalibration:\n    \trosbotControl.linear.x = xSpeed\n    \trosbotControl.angular.z = zAngularSpeed\n    \tself.speedPub.publish(rosbotControl)\n    else:\n    \tself.speedPub.publish(rosbotControl)\n\n\nFirstly we convert our cartesian coordinates to polar ones. Then we calculate angular and linear speed for ROSbot with proportional controller. We publish it if we receive message from remote that allow robot to move.\n\n\n  minHumanDistance - if human distance is more than that robot will start following\n  minHumanAngle - if human angle is more than that robot will start following\n  speedPGain - proportional gain for linear ROSbot speed (increase if you want your robot to go faster)\n  angularSpeedPGain - proportional gain for angular ROSbot speed (increase if you want your robot to turn faster)\n  buttonTimeout (seconds) - if we don’t receive new Dead Man’s Button message for that time ROSbot isn’t allowed to move\n\n\nFollowerKalman\n\nThis version is improved slow follower - basically only additions are scoring system and Kalman filter. Also I changed some parameters to make it more suitable for higher speeds.\nIn order to implement Kalman filter I created Person class where human position is stored and updated. For Kalman Filter part I used code from leg_tracker. All the parameters for filter were well tuned, I only changed std_obs value.\n\n\n  std_obs - increasing this value means you don’t trust your measurements and as the effect your data is much more filtered. Be careful with changing it too much, because it causes your estimated human position to be slower to sudden changes - if you stop, filter won’t trust as much your readings and as a result it will predict you will still move with some velocity. Consequently robot will continue moving forward and it will take some time to adjust to reality. On the other hand if you decrease it too much human position will fluctuate with uncertainties in leg detections.\n\n\nNext big change is that I added scoring system which uses all parameters: proportion, area, length and distance. It combines it with appropriate weights.\n\nproportion = max(xDistance,yDistance)/min(xDistance, yDistance)\narea = xDistance*yDistance\nwidthDifference = (max(xDistance,yDistance)-self.legWidth) - self.dLegWidth\ndistanceFromRobot = math.sqrt(xMean**2 + yMean**2)\nscore = 0\nscore += distanceFromRobot * self.distanceWeight\nscore += abs(proportion - self.destProportion) * self.proportionWeight\nscore += abs(area - self.destArea) * self.areaWeight\nif widthDifference &gt; 0:\n    score += (abs(widthDifference) * self.widthDifferenceWeight)**2\nif score &lt; self.maxScore:\n    sortedClustersDetails.append([xMean, yMean, distanceFromRobot, proportion, area, widthDifference, score])\n\n\nParameters:\n\n\n  destProportion - our desired proportion, I set it based on readings I got\n  destArea - same as above but with area\n  distanceWeight - weight we give to distance from robot\n  proportionWeight - weight we set to distance between measured proportion and desired\n  areaWeight - don’t set this weight too high, as it is not as reliable\n  widthDifferenceWeight - we set it really high, because when reading is too long, then it’s probably not a leg\n  maxScore - above that score we are certain that detection isn’t a leg\n\n\nParameters with updated values:\n\n\n  minRange (increased) - robot has to detect obstacles earlier\n  speedPGain (increased) - increase in proportional gain to obtain higher speed\n  angularSpeedPGain (increased) - same as above\n  minHumanDistance (decreased) - robot will start following earlier and be able to keep up with human\n  humanPositionChangeThreshold (increased) - person walks faster so position can change more\n  detectionTimeout (decreased) - higher speeds, so we decrease timeouts\n  buttonTimeout (decreased) - same as above\n\n\nLastly I added restrictions on obstacle detect - we only detect obstacle approximately in area where we can drive. Increasing minRange can cause ROSbot to be unable to move in narrow spaces.\n\nif (alfa &gt; -math.pi and alfa &lt; -self.maxAngle) or \\\n\t(alfa &gt; self.maxAngle and alfa &lt; math.pi):\n\n\nSummary\n\nIn this tutorial you learned how to set up and run human following using ROSbot with ESP remote. After main algorithm walkthrough you should be also able to modify it to suit your robot.\n",
    "url": "/posts_pl/2019-09-24-human-following-robot/"
  },
  
  {
    "title": "Categories",
    "excerpt": "Category index\n",
    "content": "\n",
    "url": "/categories/"
  }
  
]

